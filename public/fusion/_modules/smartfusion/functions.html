<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>smartfusion.functions &mdash; SMART FUSION 0.1b11.dev2+gf88c3944.d20220921 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> SMART FUSION
            <img src="../../_static/smart_fusion_logo.jpeg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.1b11.dev2+gf88c3944.d20220921
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../design.html">Framework Design </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../smartfusion.html">SMART FUSION Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_demos/index.html">Demonstrations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Copyright &amp; License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SMART FUSION</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>smartfusion.functions</li>
  
  <li class="wy-breadcrumbs-aside">
    <a href="https://github.com/claycurry34/Smart-Fusion/blob/main/docs/source/_modules/smartfusion/functions" class="fa fa-github"> Edit on GitHub</a>
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for smartfusion.functions</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Mathematical functions used within SMART FUSION&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..types.numeric</span> <span class="kn">import</span> <span class="n">Probability</span>
<span class="kn">from</span> <span class="nn">..types.array</span> <span class="kn">import</span> <span class="n">StateVector</span><span class="p">,</span> <span class="n">StateVectors</span><span class="p">,</span> <span class="n">CovarianceMatrix</span>


<div class="viewcode-block" id="tria"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.tria">[docs]</a><span class="k">def</span> <span class="nf">tria</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Square Root Matrix Triangularization</span>

<span class="sd">    Given a rectangular square root matrix obtain a square lower-triangular</span>
<span class="sd">    square root matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    matrix : numpy.ndarray</span>
<span class="sd">        A `n` by `m` matrix that is generally not square.</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A square lower-triangular matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">upper_triangular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">lower_triangular</span> <span class="o">=</span> <span class="n">upper_triangular</span><span class="o">.</span><span class="n">T</span>

    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span>
             <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">lower_triangular</span><span class="p">))</span>
             <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">lower_triangular</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">lower_triangular</span></div>


<div class="viewcode-block" id="cholesky_eps"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.cholesky_eps">[docs]</a><span class="k">def</span> <span class="nf">cholesky_eps</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a Cholesky decomposition on a nearly positive-definite matrix.</span>

<span class="sd">    This should return similar results to NumPy/SciPy Cholesky decompositions,</span>
<span class="sd">    but compromises for cases for non positive-definite matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : numpy.ndarray</span>
<span class="sd">        Symmetric positive-definite matrix.</span>
<span class="sd">    lower : bool</span>
<span class="sd">        Whether to return lower or upper triangular decomposition. Default</span>
<span class="sd">        `False` which returns upper.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L : numpy.ndarray</span>
<span class="sd">        Upper/lower triangular Cholesky decomposition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="nd">@L</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="nd">@L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lower</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">L</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">L</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="jacobian"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.jacobian">[docs]</a><span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute Jacobian through finite difference calculation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : function handle</span>
<span class="sd">        A (non-linear) transition function</span>
<span class="sd">        Must be of the form &quot;y = fun(x)&quot;, where y can be a scalar or \</span>
<span class="sd">        :class:`numpy.ndarray` of shape `(Nd, 1)` or `(Nd,)`</span>
<span class="sd">    x : :class:`State`</span>
<span class="sd">        A state with state vector of shape `(Ns, 1)`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jac: :class:`numpy.ndarray` of shape `(Nd, Ns)`</span>
<span class="sd">        The computed Jacobian</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ndim</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">state_vector</span><span class="p">)</span>

    <span class="c1"># For numerical reasons the step size needs to large enough. Aim for 1e-8</span>
    <span class="c1"># relative to spacing between floating point numbers for each dimension</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="c1"># But at least 1e-8</span>
    <span class="c1"># TODO: Is this needed? If not, note special case at zero.</span>
    <span class="n">delta</span><span class="p">[</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-8</span>

    <span class="n">x2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Create a clone of the input</span>
    <span class="n">x2</span><span class="o">.</span><span class="n">state_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">state_vector</span><span class="p">,</span> <span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">delta</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">x2</span><span class="o">.</span><span class="n">state_vector</span> <span class="o">=</span> <span class="n">x2</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVectors</span><span class="p">)</span>

    <span class="n">F</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">F</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndim</span><span class="p">]</span> <span class="o">-</span> <span class="n">F</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jac</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span></div>


<div class="viewcode-block" id="gauss2sigma"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.gauss2sigma">[docs]</a><span class="k">def</span> <span class="nf">gauss2sigma</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Approximate a given distribution to a Gaussian, using a</span>
<span class="sd">    deterministically selected set of sigma points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    state : :class:`~State`</span>
<span class="sd">        A state object capable of returning a :class:`~.StateVector` of</span>
<span class="sd">        shape `(Ns, 1)` representing the Gaussian mean and a</span>
<span class="sd">        :class:`~.CovarianceMatrix` of shape `(Ns, Ns)` which is the</span>
<span class="sd">        covariance of the distribution</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        Spread of the sigma points. Typically `1e-3`.</span>
<span class="sd">        (default is 1)</span>
<span class="sd">    beta : float, optional</span>
<span class="sd">        Used to incorporate prior knowledge of the distribution</span>
<span class="sd">        2 is optimal if the state is normally distributed.</span>
<span class="sd">        (default is 2)</span>
<span class="sd">    kappa : float, optional</span>
<span class="sd">        Secondary spread scaling parameter</span>
<span class="sd">        (default is calculated as `3-Ns`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`list` of length `2*Ns+1`</span>
<span class="sd">        An list of States containing the locations of the sigma points.</span>
<span class="sd">        Note that only the :attr:`state_vector` attribute in these</span>
<span class="sd">        States will be meaningful. Other quantities, like :attr:`covar`</span>
<span class="sd">        will be inherited from the input and don&#39;t really make sense</span>
<span class="sd">        for a sigma point.</span>
<span class="sd">    : :class:`numpy.ndarray` of shape `(2*Ns+1,)`</span>
<span class="sd">        An array containing the sigma point mean weights</span>
<span class="sd">    : :class:`numpy.ndarray` of shape `(2*Ns+1,)`</span>
<span class="sd">        An array containing the sigma point covariance weights</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ndim_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">kappa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kappa</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">-</span> <span class="n">ndim_state</span>

    <span class="c1"># Compute Square Root matrix via Colesky decomp.</span>
    <span class="n">sqrt_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">covar</span><span class="p">)</span>

    <span class="c1"># Calculate scaling factor for all off-center points</span>
    <span class="n">alpha2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">lamda</span> <span class="o">=</span> <span class="n">alpha2</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim_state</span> <span class="o">+</span> <span class="n">kappa</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim_state</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">ndim_state</span> <span class="o">+</span> <span class="n">lamda</span>

    <span class="c1"># Calculate sigma point locations</span>
    <span class="n">sigma_points</span> <span class="o">=</span> <span class="n">StateVectors</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ndim_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

    <span class="c1"># Cast dtype from int to float to avoid rounding errors</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">sigma_points</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="n">sigma_points</span> <span class="o">=</span> <span class="n">sigma_points</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Can&#39;t use in place addition/subtraction as casting issues may arise when mixing float/int</span>
    <span class="n">sigma_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:(</span><span class="n">ndim_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> \
        <span class="n">sigma_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:(</span><span class="n">ndim_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">sqrt_sigma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">sigma_points</span><span class="p">[:,</span> <span class="p">(</span><span class="n">ndim_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span> <span class="o">=</span> \
        <span class="n">sigma_points</span><span class="p">[:,</span> <span class="p">(</span><span class="n">ndim_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span> <span class="o">-</span> <span class="n">sqrt_sigma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="c1"># Put these sigma points into s State object list</span>
    <span class="n">sigma_points_states</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sigma_point</span> <span class="ow">in</span> <span class="n">sigma_points</span><span class="p">:</span>
        <span class="n">state_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">state_copy</span><span class="o">.</span><span class="n">state_vector</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">(</span><span class="n">sigma_point</span><span class="p">)</span>
        <span class="n">sigma_points_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state_copy</span><span class="p">)</span>

    <span class="c1"># Calculate weights</span>
    <span class="n">mean_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ndim_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mean_weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lamda</span> <span class="o">/</span> <span class="n">c</span>
    <span class="n">mean_weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">c</span>
    <span class="n">covar_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mean_weights</span><span class="p">)</span>
    <span class="n">covar_weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lamda</span> <span class="o">/</span> <span class="n">c</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha2</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sigma_points_states</span><span class="p">,</span> <span class="n">mean_weights</span><span class="p">,</span> <span class="n">covar_weights</span></div>


<div class="viewcode-block" id="sigma2gauss"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.sigma2gauss">[docs]</a><span class="k">def</span> <span class="nf">sigma2gauss</span><span class="p">(</span><span class="n">sigma_points</span><span class="p">,</span> <span class="n">mean_weights</span><span class="p">,</span> <span class="n">covar_weights</span><span class="p">,</span> <span class="n">covar_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate estimated mean and covariance from a given set of sigma points</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sigma_points : :class:`~.StateVectors` of shape `(Ns, 2*Ns+1)`</span>
<span class="sd">        An array containing the locations of the sigma points</span>
<span class="sd">    mean_weights : :class:`numpy.ndarray` of shape `(2*Ns+1,)`</span>
<span class="sd">        An array containing the sigma point mean weights</span>
<span class="sd">    covar_weights : :class:`numpy.ndarray` of shape `(2*Ns+1,)`</span>
<span class="sd">        An array containing the sigma point covariance weights</span>
<span class="sd">    covar_noise : :class:`~.CovarianceMatrix` of shape `(Ns, Ns)`, optional</span>
<span class="sd">        Additive noise covariance matrix</span>
<span class="sd">        (default is `None`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`~.StateVector` of shape `(Ns, 1)`</span>
<span class="sd">        Calculated mean</span>
<span class="sd">    : :class:`~.CovarianceMatrix` of shape `(Ns, Ns)`</span>
<span class="sd">        Calculated covariance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">sigma_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">mean_weights</span><span class="p">)</span>

    <span class="n">points_diff</span> <span class="o">=</span> <span class="n">sigma_points</span> <span class="o">-</span> <span class="n">mean</span>

    <span class="n">covar</span> <span class="o">=</span> <span class="n">points_diff</span><span class="o">@</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">covar_weights</span><span class="p">))</span><span class="o">@</span><span class="p">(</span><span class="n">points_diff</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">covar_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">covar</span> <span class="o">=</span> <span class="n">covar</span> <span class="o">+</span> <span class="n">covar_noise</span>
    <span class="k">return</span> <span class="n">mean</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVector</span><span class="p">),</span> <span class="n">covar</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CovarianceMatrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="unscented_transform"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.unscented_transform">[docs]</a><span class="k">def</span> <span class="nf">unscented_transform</span><span class="p">(</span><span class="n">sigma_points_states</span><span class="p">,</span> <span class="n">mean_weights</span><span class="p">,</span> <span class="n">covar_weights</span><span class="p">,</span>
                        <span class="n">fun</span><span class="p">,</span> <span class="n">points_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">covar_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the Unscented Transform to a set of sigma points</span>

<span class="sd">    Apply f to points (with secondary argument points_noise, if available),</span>
<span class="sd">    then approximate the resulting mean and covariance. If sigma_noise is</span>
<span class="sd">    available, treat it as additional variance due to additive noise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sigma_points : :class:`~.StateVectors` of shape `(Ns, 2*Ns+1)`</span>
<span class="sd">        An array containing the locations of the sigma points</span>
<span class="sd">    mean_weights : :class:`numpy.ndarray` of shape `(2*Ns+1,)`</span>
<span class="sd">        An array containing the sigma point mean weights</span>
<span class="sd">    covar_weights : :class:`numpy.ndarray` of shape `(2*Ns+1,)`</span>
<span class="sd">        An array containing the sigma point covariance weights</span>
<span class="sd">    fun : function handle</span>
<span class="sd">        A (non-linear) transition function</span>
<span class="sd">        Must be of the form &quot;y = fun(x,w)&quot;, where y can be a scalar or \</span>
<span class="sd">        :class:`numpy.ndarray` of shape `(Ns, 1)` or `(Ns,)`</span>
<span class="sd">    covar_noise : :class:`~.CovarianceMatrix` of shape `(Ns, Ns)`, optional</span>
<span class="sd">        Additive noise covariance matrix</span>
<span class="sd">        (default is `None`)</span>
<span class="sd">    points_noise : :class:`numpy.ndarray` of shape `(Ns, 2*Ns+1,)`, optional</span>
<span class="sd">        points to pass into f&#39;s second argument</span>
<span class="sd">        (default is `None`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`~.StateVector` of shape `(Ns, 1)`</span>
<span class="sd">        Transformed mean</span>
<span class="sd">    : :class:`~.CovarianceMatrix` of shape `(Ns, Ns)`</span>
<span class="sd">        Transformed covariance</span>
<span class="sd">    : :class:`~.CovarianceMatrix` of shape `(Ns,Nm)`</span>
<span class="sd">        Calculated cross-covariance matrix</span>
<span class="sd">    : :class:`~.StateVectors` of shape `(Ns, 2*Ns+1)`</span>
<span class="sd">        An array containing the locations of the transformed sigma points</span>
<span class="sd">    : :class:`numpy.ndarray` of shape `(2*Ns+1,)`</span>
<span class="sd">        An array containing the transformed sigma point mean weights</span>
<span class="sd">    : :class:`numpy.ndarray` of shape `(2*Ns+1,)`</span>
<span class="sd">        An array containing the transformed sigma point covariance weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reconstruct the sigma_points matrix</span>
    <span class="n">sigma_points</span> <span class="o">=</span> <span class="n">StateVectors</span><span class="p">([</span>
        <span class="n">sigma_points_state</span><span class="o">.</span><span class="n">state_vector</span> <span class="k">for</span> <span class="n">sigma_points_state</span> <span class="ow">in</span> <span class="n">sigma_points_states</span><span class="p">])</span>

    <span class="c1"># Transform points through f</span>
    <span class="k">if</span> <span class="n">points_noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigma_points_t</span> <span class="o">=</span> <span class="n">StateVectors</span><span class="p">([</span>
            <span class="n">fun</span><span class="p">(</span><span class="n">sigma_points_state</span><span class="p">)</span> <span class="k">for</span> <span class="n">sigma_points_state</span> <span class="ow">in</span> <span class="n">sigma_points_states</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigma_points_t</span> <span class="o">=</span> <span class="n">StateVectors</span><span class="p">([</span>
            <span class="n">fun</span><span class="p">(</span><span class="n">sigma_points_state</span><span class="p">,</span> <span class="n">points_noise</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sigma_points_state</span><span class="p">,</span> <span class="n">point_noise</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sigma_points_states</span><span class="p">,</span> <span class="n">points_noise</span><span class="o">.</span><span class="n">T</span><span class="p">)])</span>

    <span class="c1"># Calculate mean and covariance approximation</span>
    <span class="n">mean</span><span class="p">,</span> <span class="n">covar</span> <span class="o">=</span> <span class="n">sigma2gauss</span><span class="p">(</span><span class="n">sigma_points_t</span><span class="p">,</span> <span class="n">mean_weights</span><span class="p">,</span> <span class="n">covar_weights</span><span class="p">,</span> <span class="n">covar_noise</span><span class="p">)</span>

    <span class="c1"># Calculate cross-covariance</span>
    <span class="n">cross_covar</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">sigma_points</span><span class="o">-</span><span class="n">sigma_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mean_weights</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">sigma_points_t</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CovarianceMatrix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covar</span><span class="p">,</span> <span class="n">cross_covar</span><span class="p">,</span> <span class="n">sigma_points_t</span><span class="p">,</span> <span class="n">mean_weights</span><span class="p">,</span> <span class="n">covar_weights</span></div>


<div class="viewcode-block" id="cart2pol"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.cart2pol">[docs]</a><span class="k">def</span> <span class="nf">cart2pol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Cartesian coordinates to Polar</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: float</span>
<span class="sd">        The x coordinate</span>
<span class="sd">    y: float</span>
<span class="sd">        the y coordinate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (float, float)</span>
<span class="sd">        A tuple of the form `(range, bearing)`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span></div>


<div class="viewcode-block" id="cart2sphere"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.cart2sphere">[docs]</a><span class="k">def</span> <span class="nf">cart2sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Cartesian coordinates to Spherical</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: float</span>
<span class="sd">        The x coordinate</span>
<span class="sd">    y: float</span>
<span class="sd">        the y coordinate</span>
<span class="sd">    z: float</span>
<span class="sd">        the z coordinate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (float, float, float)</span>
<span class="sd">        A tuple of the form `(range, bearing, elevation)`</span>
<span class="sd">        bearing and elevation in radians. Elevation is measured from x, y plane</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">z</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="cart2angles"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.cart2angles">[docs]</a><span class="k">def</span> <span class="nf">cart2angles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Cartesian coordinates to Angles</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: float</span>
<span class="sd">        The x coordinate</span>
<span class="sd">    y: float</span>
<span class="sd">        the y coordinate</span>
<span class="sd">    z: float</span>
<span class="sd">        the z coordinate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (float, float)</span>
<span class="sd">        A tuple of the form `(bearing, elevation)`</span>
<span class="sd">        bearing and elevation in radians. Elevation is measured from x, y plane</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">cart2sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="pol2cart"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.pol2cart">[docs]</a><span class="k">def</span> <span class="nf">pol2cart</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Polar coordinates to Cartesian</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rho: float</span>
<span class="sd">        Range(a.k.a. radial distance)</span>
<span class="sd">    phi: float</span>
<span class="sd">        Bearing, expressed in radians</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (float, float)</span>
<span class="sd">        A tuple of the form `(x, y)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="sphere2cart"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.sphere2cart">[docs]</a><span class="k">def</span> <span class="nf">sphere2cart</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Polar coordinates to Cartesian</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rho: float</span>
<span class="sd">        Range(a.k.a. radial distance)</span>
<span class="sd">    phi: float</span>
<span class="sd">        Bearing, expressed in radians</span>
<span class="sd">    theta: float</span>
<span class="sd">        Elevation expressed in radians, measured from x, y plane</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (float, float, float)</span>
<span class="sd">        A tuple of the form `(x, y, z)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="rotx"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.rotx">[docs]</a><span class="k">def</span> <span class="nf">rotx</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rotation matrix for rotations around x-axis</span>

<span class="sd">    For a given rotation angle: :math:`\theta`, this function evaluates \</span>
<span class="sd">    and returns the rotation matrix:</span>

<span class="sd">    .. math:: R_{x}(\theta) = \begin{bmatrix}</span>
<span class="sd">                        1 &amp; 0 &amp; 0 \\</span>
<span class="sd">                        0 &amp; cos(\theta) &amp; -sin(\theta) \\</span>
<span class="sd">                        0 &amp; sin(\theta) &amp; cos(\theta)</span>
<span class="sd">                        \end{bmatrix}</span>
<span class="sd">       :label: Rx</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta: Union[float, np.ndarray]</span>
<span class="sd">        Rotation angle specified as a real-valued number or an \</span>
<span class="sd">        :class:`np.ndarray` of reals. The rotation angle is positive if the \</span>
<span class="sd">        rotation is in the clockwise direction when viewed by an observer \</span>
<span class="sd">        looking down the x-axis towards the origin. Angle units are in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`numpy.ndarray` of shape (3, 3) or (3, 3, n) for array input</span>
<span class="sd">        Rotation matrix around x-axis of the form :eq:`Rx`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">one</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">zero</span><span class="p">],</span>
                     <span class="p">[</span><span class="n">zero</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">],</span>
                     <span class="p">[</span><span class="n">zero</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span></div>


<div class="viewcode-block" id="roty"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.roty">[docs]</a><span class="k">def</span> <span class="nf">roty</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rotation matrix for rotations around y-axis</span>

<span class="sd">    For a given rotation angle: :math:`\theta`, this function evaluates \</span>
<span class="sd">    and returns the rotation matrix:</span>

<span class="sd">    .. math::</span>
<span class="sd">        R_{y}(\theta) = \begin{bmatrix}</span>
<span class="sd">                        cos(\theta) &amp; 0 &amp; sin(\theta) \\</span>
<span class="sd">                        0 &amp; 1 &amp; 0 \\</span>
<span class="sd">                        - sin(\theta) &amp; 0 &amp; cos(\theta)</span>
<span class="sd">                        \end{bmatrix}</span>
<span class="sd">       :label: Ry</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta: Union[float, np.ndarray]</span>
<span class="sd">        Rotation angle specified as a real-valued number or an \</span>
<span class="sd">        :class:`np.ndarray` of reals. The rotation angle is positive if the \</span>
<span class="sd">        rotation is in the clockwise direction when viewed by an observer \</span>
<span class="sd">        looking down the y-axis towards the origin. Angle units are in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`numpy.ndarray` of shape (3, 3) or (3, 3, n) for array input</span>
<span class="sd">        Rotation matrix around y-axis of the form :eq:`Ry`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">s</span><span class="p">],</span>
                     <span class="p">[</span><span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">zero</span><span class="p">],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span></div>


<div class="viewcode-block" id="rotz"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.rotz">[docs]</a><span class="k">def</span> <span class="nf">rotz</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rotation matrix for rotations around z-axis</span>

<span class="sd">    For a given rotation angle: :math:`\theta`, this function evaluates \</span>
<span class="sd">    and returns the rotation matrix:</span>

<span class="sd">    .. math::</span>
<span class="sd">        R_{z}(\theta) = \begin{bmatrix}</span>
<span class="sd">                        cos(\theta) &amp; -sin(\theta) &amp; 0 \\</span>
<span class="sd">                        sin(\theta) &amp; cos(\theta) &amp; 0 \\</span>
<span class="sd">                        0 &amp; 0 &amp; 1</span>
<span class="sd">                        \end{bmatrix}</span>
<span class="sd">       :label: Rz</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta: Union[float, np.ndarray]</span>
<span class="sd">        Rotation angle specified as a real-valued number or an \</span>
<span class="sd">        :class:`np.ndarray` of reals. The rotation angle is positive if the \</span>
<span class="sd">        rotation is in the clockwise direction when viewed by an observer \</span>
<span class="sd">        looking down the z-axis towards the origin. Angle units are in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`numpy.ndarray` of shape (3, 3) or (3, 3, n) for array input</span>
<span class="sd">        Rotation matrix around z-axis of the form :eq:`Rz`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">zero</span><span class="p">],</span>
                     <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">zero</span><span class="p">],</span>
                     <span class="p">[</span><span class="n">zero</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">]])</span></div>


<div class="viewcode-block" id="gm_reduce_single"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.gm_reduce_single">[docs]</a><span class="k">def</span> <span class="nf">gm_reduce_single</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">covars</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reduce mixture of multi-variate Gaussians to single Gaussian</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    means : :class:`~.StateVectors`</span>
<span class="sd">        The means of the GM components</span>
<span class="sd">    covars : np.array of shape (num_dims, num_dims, num_components)</span>
<span class="sd">        The covariance matrices of the GM components</span>
<span class="sd">    weights : np.array of shape (num_components,)</span>
<span class="sd">        The weights of the GM components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`~.StateVector`</span>
<span class="sd">        The mean of the reduced/single Gaussian</span>
<span class="sd">    : :class:`~.CovarianceMatrix`</span>
<span class="sd">        The covariance of the reduced/single Gaussian</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Normalise weights such that they sum to 1</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">/</span><span class="n">Probability</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Cast means as a StateVectors, so this works with ndarray types</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVectors</span><span class="p">)</span>

    <span class="c1"># Calculate mean</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Calculate covar</span>
    <span class="n">delta_means</span> <span class="o">=</span> <span class="n">means</span> <span class="o">-</span> <span class="n">mean</span>
    <span class="n">covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">covars</span><span class="o">*</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span> <span class="o">+</span> <span class="n">weights</span><span class="o">*</span><span class="n">delta_means</span><span class="nd">@delta_means</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">mean</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVector</span><span class="p">),</span> <span class="n">covar</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CovarianceMatrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="mod_bearing"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.mod_bearing">[docs]</a><span class="k">def</span> <span class="nf">mod_bearing</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the modulus of a bearing. Bearing angles are within the \</span>
<span class="sd">    range :math:`-\pi` to :math:`\pi`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: float</span>
<span class="sd">        bearing angle in radians</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Angle in radians in the range math: :math:`-\pi` to :math:`+\pi`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="mod_elevation"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.mod_elevation">[docs]</a><span class="k">def</span> <span class="nf">mod_elevation</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the modulus of an elevation angle. Elevation angles \</span>
<span class="sd">    are within the range :math:`-\pi/2` to :math:`\pi/2`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: float</span>
<span class="sd">        elevation angle in radians</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Angle in radians in the range math: :math:`-\pi/2` to :math:`+\pi/2`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># limit to 2*pi</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">//</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># Count # of 90 deg multiples</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="build_rotation_matrix"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.build_rotation_matrix">[docs]</a><span class="k">def</span> <span class="nf">build_rotation_matrix</span><span class="p">(</span><span class="n">angle_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates and returns the (3D) axis rotation matrix given a vector of</span>
<span class="sd">    three angles:</span>
<span class="sd">    [roll, pitch/elevation, yaw/azimuth]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        angle_vector : :class:`numpy.ndarray` of shape (3, 1): the rotations</span>
<span class="sd">        about the :math:&#39;x, y, z&#39; axes.</span>
<span class="sd">        In aircraft/radar terms these correspond to</span>
<span class="sd">        [roll, pitch/elevation, yaw/azimuth]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        :class:`numpy.ndarray` of shape (3, 3)</span>
<span class="sd">            The model (3D) rotation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">theta_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">angle_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># roll</span>
    <span class="n">theta_y</span> <span class="o">=</span> <span class="n">angle_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># pitch#elevation</span>
    <span class="n">theta_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">angle_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># yaw#azimuth</span>
    <span class="k">return</span> <span class="n">rotz</span><span class="p">(</span><span class="n">theta_z</span><span class="p">)</span> <span class="o">@</span> <span class="n">roty</span><span class="p">(</span><span class="n">theta_y</span><span class="p">)</span> <span class="o">@</span> <span class="n">rotx</span><span class="p">(</span><span class="n">theta_x</span><span class="p">)</span></div>


<div class="viewcode-block" id="dotproduct"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.dotproduct">[docs]</a><span class="k">def</span> <span class="nf">dotproduct</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the dot (or scalar) product of two StateVectors.</span>

<span class="sd">    The result for vectors of length :math:`n` is</span>
<span class="sd">    :math:`\Sigma_i^n a_i b_i`.</span>

<span class="sd">    Inputs are state vectors, i.e. the second dimension is 1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : StateVector</span>
<span class="sd">        A state vector</span>
<span class="sd">    b : StateVector</span>
<span class="sd">        A state vector of equal length to :math:`a`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : float</span>
<span class="sd">        A scalar value representing the dot product of the vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inputs must be column vectors&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input vectors must be the same length&quot;</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">a_i</span><span class="p">,</span> <span class="n">b_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">a_i</span><span class="o">*</span><span class="n">b_i</span>

    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="sde_euler_maruyama_integration"><a class="viewcode-back" href="../../smartfusion.functions.html#smartfusion.functions.sde_euler_maruyama_integration">[docs]</a><span class="k">def</span> <span class="nf">sde_euler_maruyama_integration</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">t_values</span><span class="p">,</span> <span class="n">state_x0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform SDE Euler Maruyama Integration</span>

<span class="sd">    Performs Stochastic Differential Equation Integration using the Euler</span>
<span class="sd">    Maruyama method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        Function to integrate.</span>
<span class="sd">    t_values : list of :class:`float`</span>
<span class="sd">        Time values to integrate over</span>
<span class="sd">    state_x0 : :class:`~.State`</span>
<span class="sd">        Initial state for time in first value in :obj:`t_values`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : :class:`~.StateVector`</span>
<span class="sd">        Final value for the time in last value in :obj:`t_values`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state_x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">state_x0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">next_t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">delta_t</span> <span class="o">=</span> <span class="n">next_t</span> <span class="o">-</span> <span class="n">t</span>
        <span class="n">delta_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta_t</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">state_x</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">state_x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">state_x</span><span class="o">.</span><span class="n">state_vector</span> <span class="o">=</span> <span class="n">state_x</span><span class="o">.</span><span class="n">state_vector</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">delta_t</span> <span class="o">+</span> <span class="n">b</span><span class="nd">@delta_w</span>
    <span class="k">return</span> <span class="n">state_x</span><span class="o">.</span><span class="n">state_vector</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../copyright.html">Copyright</a> 2017-2022 SMART FUSION contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>