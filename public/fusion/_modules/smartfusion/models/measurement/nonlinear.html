<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>smartfusion.models.measurement.nonlinear &mdash; SMART FUSION 0.1b11.dev2+gf88c3944.d20220921 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../../copyright.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> SMART FUSION
            <img src="../../../../_static/smart_fusion_logo.jpeg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.1b11.dev2+gf88c3944.d20220921
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../design.html">Framework Design </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../smartfusion.html">SMART FUSION Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto_tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto_demos/index.html">Demonstrations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../copyright.html">Copyright &amp; License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">SMART FUSION</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>smartfusion.models.measurement.nonlinear</li>
  
  <li class="wy-breadcrumbs-aside">
    <a href="https://github.com/claycurry34/Smart-Fusion/blob/main/docs/source/_modules/smartfusion/models/measurement/nonlinear" class="fa fa-github"> Edit on GitHub</a>
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for smartfusion.models.measurement.nonlinear</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">inv</span><span class="p">,</span> <span class="n">pinv</span><span class="p">,</span> <span class="n">block_diag</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">multivariate_normal</span>

<span class="kn">from</span> <span class="nn">...base</span> <span class="kn">import</span> <span class="n">Property</span><span class="p">,</span> <span class="n">clearable_cached_property</span>
<span class="kn">from</span> <span class="nn">...types.numeric</span> <span class="kn">import</span> <span class="n">Probability</span>

<span class="kn">from</span> <span class="nn">...functions</span> <span class="kn">import</span> <span class="n">cart2pol</span><span class="p">,</span> <span class="n">pol2cart</span><span class="p">,</span> \
    <span class="n">cart2sphere</span><span class="p">,</span> <span class="n">sphere2cart</span><span class="p">,</span> <span class="n">cart2angles</span><span class="p">,</span> \
    <span class="n">build_rotation_matrix</span>
<span class="kn">from</span> <span class="nn">...types.array</span> <span class="kn">import</span> <span class="n">StateVector</span><span class="p">,</span> <span class="n">CovarianceMatrix</span><span class="p">,</span> <span class="n">StateVectors</span>
<span class="kn">from</span> <span class="nn">...types.angle</span> <span class="kn">import</span> <span class="n">Bearing</span><span class="p">,</span> <span class="n">Elevation</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="kn">import</span> <span class="n">LinearModel</span><span class="p">,</span> <span class="n">GaussianModel</span><span class="p">,</span> <span class="n">ReversibleModel</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">MeasurementModel</span>


<div class="viewcode-block" id="CombinedReversibleGaussianMeasurementModel"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CombinedReversibleGaussianMeasurementModel">[docs]</a><span class="k">class</span> <span class="nc">CombinedReversibleGaussianMeasurementModel</span><span class="p">(</span><span class="n">ReversibleModel</span><span class="p">,</span> <span class="n">GaussianModel</span><span class="p">,</span> <span class="n">MeasurementModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Combine multiple models into a single model by stacking them.</span>

<span class="sd">    The assumption is that all models are Gaussian, and must be combination of</span>
<span class="sd">    :class:`~.LinearModel` and :class:`~.NonLinearModel` models. They must all</span>
<span class="sd">    expect the same dimension state vector (i.e. have the same</span>
<span class="sd">    :attr:`~.MeasurementModel.ndim_state`), using model mapping as appropriate.</span>

<span class="sd">    This also implements the :meth:`inverse_function`, but will raise a</span>
<span class="sd">    :exc:`NotImplementedError` if any model isn&#39;t either a</span>
<span class="sd">    :class:`~.LinearModel` or :class:`~.ReversibleModel`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model_list</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">GaussianModel</span><span class="p">]</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s2">&quot;List of Measurement Models.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">ndim_state</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim_state</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Models must all have the same `ndim_state`&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of state dimensions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">ndim_meas</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">mapping</span><span class="p">]</span>

<div class="viewcode-block" id="CombinedReversibleGaussianMeasurementModel.function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CombinedReversibleGaussianMeasurementModel.function">[docs]</a>    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">model</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVector</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_linear_inverse_function</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">model_matrix</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">inv_model_matrix</span> <span class="o">=</span> <span class="n">pinv</span><span class="p">(</span><span class="n">model_matrix</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inv_model_matrix</span><span class="nd">@state</span><span class="o">.</span><span class="n">state_vector</span>

<div class="viewcode-block" id="CombinedReversibleGaussianMeasurementModel.inverse_function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CombinedReversibleGaussianMeasurementModel.inverse_function">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detection</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">detection</span><span class="p">)</span>
        <span class="n">ndim_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">state_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVector</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span> <span class="o">=</span> <span class="n">detection</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="n">ndim_count</span><span class="p">:</span><span class="n">model</span><span class="o">.</span><span class="n">ndim_meas</span> <span class="o">+</span> <span class="n">ndim_count</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">ReversibleModel</span><span class="p">):</span>
                <span class="n">state_vector</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">inverse_function</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">LinearModel</span><span class="p">):</span>
                <span class="n">state_vector</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear_inverse_function</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Model </span><span class="si">{!r}</span><span class="s2"> not reversible&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)))</span>
            <span class="n">ndim_count</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">ndim_meas</span>

        <span class="k">return</span> <span class="n">state_vector</span></div>

<div class="viewcode-block" id="CombinedReversibleGaussianMeasurementModel.covar"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CombinedReversibleGaussianMeasurementModel.covar">[docs]</a>    <span class="k">def</span> <span class="nf">covar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CovarianceMatrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">block_diag</span><span class="p">(</span>
            <span class="o">*</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">covar</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CovarianceMatrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="CombinedReversibleGaussianMeasurementModel.rvs"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CombinedReversibleGaussianMeasurementModel.rvs">[docs]</a>    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">StateVector</span><span class="p">,</span> <span class="n">StateVectors</span><span class="p">]:</span>
        <span class="n">rvs_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">model</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">num_samples</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rvs_vectors</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVector</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rvs_vectors</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVectors</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NonLinearGaussianMeasurement"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.NonLinearGaussianMeasurement">[docs]</a><span class="k">class</span> <span class="nc">NonLinearGaussianMeasurement</span><span class="p">(</span><span class="n">MeasurementModel</span><span class="p">,</span> <span class="n">GaussianModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This class combines the MeasurementModel, NonLinearModel and \</span>
<span class="sd">    GaussianModel classes. It is not meant to be instantiated directly \</span>
<span class="sd">    but subclasses should be derived from this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">noise_covar</span><span class="p">:</span> <span class="n">CovarianceMatrix</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Noise covariance&quot;</span><span class="p">)</span>
    <span class="n">rotation_offset</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 3x1 array of angles (rad), specifying the clockwise rotation &quot;</span>
            <span class="s2">&quot;around each Cartesian axis in the order :math:`x,y,z`. &quot;</span>
            <span class="s2">&quot;The rotation angles are positive if the rotation is in the &quot;</span>
            <span class="s2">&quot;counter-clockwise direction when viewed by an observer looking &quot;</span>
            <span class="s2">&quot;along the respective rotation axis, towards the origin.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that the rotation offset is initiated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Set values to defaults if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_offset</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

<div class="viewcode-block" id="NonLinearGaussianMeasurement.covar"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.NonLinearGaussianMeasurement.covar">[docs]</a>    <span class="k">def</span> <span class="nf">covar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CovarianceMatrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the measurement model noise covariance matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.CovarianceMatrix` of shape\</span>
<span class="sd">        (:py:attr:`~ndim_meas`, :py:attr:`~ndim_meas`)</span>
<span class="sd">            The measurement noise covariance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_covar</span></div>

    <span class="nd">@clearable_cached_property</span><span class="p">(</span><span class="s1">&#39;rotation_offset&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;3D axis rotation matrix&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">build_rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_offset</span><span class="p">)</span></div>


<div class="viewcode-block" id="CartesianToElevationBearingRange"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearingRange">[docs]</a><span class="k">class</span> <span class="nc">CartesianToElevationBearingRange</span><span class="p">(</span><span class="n">NonLinearGaussianMeasurement</span><span class="p">,</span> <span class="n">ReversibleModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is a class implementation of a time-invariant measurement model, \</span>
<span class="sd">    where measurements are assumed to be received in the form of bearing \</span>
<span class="sd">    (:math:`\phi`), elevation (:math:`\theta`) and range (:math:`r`), with \</span>
<span class="sd">    Gaussian noise in each dimension.</span>

<span class="sd">    The model is described by the following equations:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = h(\vec{x}_t, \vec{v}_t)</span>

<span class="sd">    where:</span>

<span class="sd">    * :math:`\vec{y}_t` is a measurement vector of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = \begin{bmatrix}</span>
<span class="sd">                \theta \\</span>
<span class="sd">                \phi \\</span>
<span class="sd">                r</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    * :math:`h` is a non-linear model function of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      h(\vec{x}_t,\vec{v}_t) = \begin{bmatrix}</span>
<span class="sd">                asin(\mathcal{z}/\sqrt{\mathcal{x}^2 + \mathcal{y}^2 +\mathcal{z}^2}) \\</span>
<span class="sd">                atan2(\mathcal{y},\mathcal{x}) \\</span>
<span class="sd">                \sqrt{\mathcal{x}^2 + \mathcal{y}^2 + \mathcal{z}^2}</span>
<span class="sd">                \end{bmatrix} + \vec{v}_t</span>

<span class="sd">    * :math:`\vec{v}_t` is Gaussian distributed with covariance :math:`R`, i.e.:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{v}_t \sim \mathcal{N}(0,R)</span>

<span class="sd">    .. math::</span>

<span class="sd">      R = \begin{bmatrix}</span>
<span class="sd">            \sigma_{\theta}^2 &amp; 0 &amp; 0 \\</span>
<span class="sd">            0 &amp; \sigma_{\phi}^2 &amp; 0 \\</span>
<span class="sd">            0 &amp; 0 &amp; \sigma_{r}^2</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    The :py:attr:`mapping` property of the model is a 3 element vector, \</span>
<span class="sd">    whose first (i.e. :py:attr:`mapping[0]`), second (i.e. \</span>
<span class="sd">    :py:attr:`mapping[1]`) and third (i.e. :py:attr:`mapping[2]`) elements \</span>
<span class="sd">    contain the state index of the :math:`x`, :math:`y` and :math:`z`  \</span>
<span class="sd">    coordinates, respectively.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    The current implementation of this class assumes a 3D Cartesian plane.</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa:E501</span>

    <span class="n">translation_offset</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 3x1 array specifying the Cartesian origin offset in terms of :math:`x,y,z` &quot;</span>
            <span class="s2">&quot;coordinates.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that the translation offset is initiated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Set values to defaults if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;ndim_meas getter method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`int`</span>
<span class="sd">            The number of measurement dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">3</span>

<div class="viewcode-block" id="CartesianToElevationBearingRange.function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearingRange.function">[docs]</a>    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model function :math:`h(\vec{x}_t,\vec{v}_t)`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state: :class:`~.State`</span>
<span class="sd">            An input state</span>
<span class="sd">        noise: :class:`numpy.ndarray` or bool</span>
<span class="sd">            An externally generated random process noise sample (the default is</span>
<span class="sd">            `False`, in which case no noise will be added</span>
<span class="sd">            if &#39;True&#39;, the output of :meth:`~.Model.rvs` is added)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.ndarray` of shape (:py:attr:`~ndim_state`, 1)</span>
<span class="sd">            The model function evaluated given the provided time interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Account for origin offset</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span>

        <span class="c1"># Rotate coordinates</span>
        <span class="n">xyz_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span> <span class="o">@</span> <span class="n">xyz</span>

        <span class="c1"># Convert to Spherical</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">cart2sphere</span><span class="p">(</span><span class="n">xyz_rot</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xyz_rot</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xyz_rot</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">elevations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Elevation</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">theta</span><span class="p">]</span>
        <span class="n">bearings</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phi</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">StateVectors</span><span class="p">([</span><span class="n">elevations</span><span class="p">,</span> <span class="n">bearings</span><span class="p">,</span> <span class="n">rho</span><span class="p">])</span> <span class="o">+</span> <span class="n">noise</span></div>

<div class="viewcode-block" id="CartesianToElevationBearingRange.inverse_function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearingRange.inverse_function">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detection</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>

        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">detection</span><span class="o">.</span><span class="n">state_vector</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">(</span><span class="n">sphere2cart</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span>

        <span class="n">inv_rotation_matrix</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">inv_rotation_matrix</span> <span class="o">@</span> <span class="n">xyz</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVector</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="CartesianToElevationBearingRange.rvs"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearingRange.rvs">[docs]</a>    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">StateVector</span><span class="p">,</span> <span class="n">StateVectors</span><span class="p">]:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Elevation</span><span class="p">(</span><span class="mf">0.</span><span class="p">)],</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="mf">0.</span><span class="p">)],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]])</span> <span class="o">+</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="CartesianToBearingRange"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToBearingRange">[docs]</a><span class="k">class</span> <span class="nc">CartesianToBearingRange</span><span class="p">(</span><span class="n">NonLinearGaussianMeasurement</span><span class="p">,</span> <span class="n">ReversibleModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is a class implementation of a time-invariant measurement model, \</span>
<span class="sd">    where measurements are assumed to be received in the form of bearing \</span>
<span class="sd">    (:math:`\phi`) and range (:math:`r`), with Gaussian noise in each dimension.</span>

<span class="sd">    The model is described by the following equations:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = h(\vec{x}_t, \vec{v}_t)</span>

<span class="sd">    where:</span>

<span class="sd">    * :math:`\vec{y}_t` is a measurement vector of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = \begin{bmatrix}</span>
<span class="sd">                \phi \\</span>
<span class="sd">                r</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    * :math:`h` is a non-linear model function of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      h(\vec{x}_t,\vec{v}_t) = \begin{bmatrix}</span>
<span class="sd">                atan2(\mathcal{y},\mathcal{x}) \\</span>
<span class="sd">                \sqrt{\mathcal{x}^2 + \mathcal{y}^2}</span>
<span class="sd">                \end{bmatrix} + \vec{v}_t</span>

<span class="sd">    * :math:`\vec{v}_t` is Gaussian distributed with covariance :math:`R`, i.e.:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{v}_t \sim \mathcal{N}(0,R)</span>

<span class="sd">    .. math::</span>

<span class="sd">      R = \begin{bmatrix}</span>
<span class="sd">            \sigma_{\phi}^2 &amp; 0 \\</span>
<span class="sd">            0 &amp; \sigma_{r}^2</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    The :py:attr:`mapping` property of the model is a 2 element vector, \</span>
<span class="sd">    whose first (i.e. :py:attr:`mapping[0]`) and second (i.e. \</span>
<span class="sd">    :py:attr:`mapping[1]`) elements contain the state index of the \</span>
<span class="sd">    :math:`x` and :math:`y` coordinates, respectively.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    The current implementation of this class assumes a 2D Cartesian plane.</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa:E501</span>

    <span class="n">translation_offset</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 2x1 array specifying the origin offset in terms of :math:`x,y` coordinates.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that the translation offset is initiated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Set values to defaults if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;ndim_meas getter method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`int`</span>
<span class="sd">            The number of measurement dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">2</span>

<div class="viewcode-block" id="CartesianToBearingRange.inverse_function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToBearingRange.inverse_function">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detection</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Measurement model assumes 2D space. </span><span class="se">\</span>
<span class="s2">                Rotation in 3D space is unsupported at this time.&quot;</span><span class="p">)</span>

        <span class="n">phi</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">detection</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[:]</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">(</span><span class="n">pol2cart</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span>

        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xy</span><span class="p">,</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inv_rotation_matrix</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">inv_rotation_matrix</span> <span class="o">@</span> <span class="n">xyz</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">StateVector</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="CartesianToBearingRange.function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToBearingRange.function">[docs]</a>    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model function :math:`h(\vec{x}_t,\vec{v}_t)`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state: :class:`~.State`</span>
<span class="sd">            An input state</span>
<span class="sd">        noise: :class:`numpy.ndarray` or bool</span>
<span class="sd">            An externally generated random process noise sample (the default is</span>
<span class="sd">            `False`, in which case no noise will be added</span>
<span class="sd">            if &#39;True&#39;, the output of :meth:`~.Model.rvs` is added)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.ndarray` of shape (:py:attr:`~ndim_meas`, 1)</span>
<span class="sd">            The model function evaluated given the provided time interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Account for origin offset</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">])</span>

        <span class="c1"># Rotate coordinates</span>
        <span class="n">xyz_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span> <span class="o">@</span> <span class="n">xyz</span>

        <span class="c1"># Covert to polar</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2pol</span><span class="p">(</span><span class="o">*</span><span class="n">xyz_rot</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">bearings</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phi</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">StateVectors</span><span class="p">([</span><span class="n">bearings</span><span class="p">,</span> <span class="n">rho</span><span class="p">])</span> <span class="o">+</span> <span class="n">noise</span></div>

<div class="viewcode-block" id="CartesianToBearingRange.rvs"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToBearingRange.rvs">[docs]</a>    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">StateVector</span><span class="p">,</span> <span class="n">StateVectors</span><span class="p">]:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Bearing</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]])</span> <span class="o">+</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="CartesianToElevationBearing"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearing">[docs]</a><span class="k">class</span> <span class="nc">CartesianToElevationBearing</span><span class="p">(</span><span class="n">NonLinearGaussianMeasurement</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is a class implementation of a time-invariant measurement model, \</span>
<span class="sd">    where measurements are assumed to be received in the form of bearing \</span>
<span class="sd">    (:math:`\phi`) and elevation (:math:`\theta`) and with \</span>
<span class="sd">    Gaussian noise in each dimension.</span>

<span class="sd">    The model is described by the following equations:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = h(\vec{x}_t, \vec{v}_t)</span>

<span class="sd">    where:</span>

<span class="sd">    * :math:`\vec{y}_t` is a measurement vector of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = \begin{bmatrix}</span>
<span class="sd">                \theta \\</span>
<span class="sd">                \phi</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    * :math:`h` is a non-linear model function of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      h(\vec{x}_t,\vec{v}_t) = \begin{bmatrix}</span>
<span class="sd">                asin(\mathcal{z}/\sqrt{\mathcal{x}^2 + \mathcal{y}^2 +\mathcal{z}^2}) \\</span>
<span class="sd">                atan2(\mathcal{y},\mathcal{x}) \\</span>
<span class="sd">                \end{bmatrix} + \vec{v}_t</span>

<span class="sd">    * :math:`\vec{v}_t` is Gaussian distributed with covariance :math:`R`, i.e.:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{v}_t \sim \mathcal{N}(0,R)</span>

<span class="sd">    .. math::</span>

<span class="sd">      R = \begin{bmatrix}</span>
<span class="sd">            \sigma_{\theta}^2 &amp; 0 \\</span>
<span class="sd">            0 &amp; \sigma_{\phi}^2\\</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    The :py:attr:`mapping` property of the model is a 3 element vector, \</span>
<span class="sd">    whose first (i.e. :py:attr:`mapping[0]`), second (i.e. \</span>
<span class="sd">    :py:attr:`mapping[1]`) and third (i.e. :py:attr:`mapping[2]`) elements  \</span>
<span class="sd">    contain the state index of the :math:`x`, :math:`y` and :math:`z`  \</span>
<span class="sd">    coordinates, respectively.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    The current implementation of this class assumes a 3D Cartesian plane.</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa:E501</span>

    <span class="n">translation_offset</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 3x1 array specifying the origin offset in terms of :math:`x,y,z` coordinates.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that the translation offset is initiated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Set values to defaults if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;ndim_meas getter method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`int`</span>
<span class="sd">            The number of measurement dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">2</span>

<div class="viewcode-block" id="CartesianToElevationBearing.function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearing.function">[docs]</a>    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model function :math:`h(\vec{x}_t,\vec{v}_t)`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state: :class:`~.State`</span>
<span class="sd">            An input state</span>
<span class="sd">        noise: :class:`numpy.ndarray` or bool</span>
<span class="sd">            An externally generated random process noise sample (the default is</span>
<span class="sd">            `False`, in which case no noise will be added</span>
<span class="sd">            if &#39;True&#39;, the output of :meth:`~.Model.rvs` is added)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.ndarray` of shape (:py:attr:`~ndim_state`, 1)</span>
<span class="sd">            The model function evaluated given the provided time interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Account for origin offset</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span>

        <span class="c1"># Rotate coordinates</span>
        <span class="n">xyz_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span> <span class="o">@</span> <span class="n">xyz</span>

        <span class="c1"># Convert to Angles</span>
        <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">cart2angles</span><span class="p">(</span><span class="n">xyz_rot</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xyz_rot</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xyz_rot</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>

        <span class="n">bearings</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phi</span><span class="p">]</span>
        <span class="n">elevations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Elevation</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">theta</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">StateVectors</span><span class="p">([</span><span class="n">elevations</span><span class="p">,</span> <span class="n">bearings</span><span class="p">])</span> <span class="o">+</span> <span class="n">noise</span></div>

<div class="viewcode-block" id="CartesianToElevationBearing.rvs"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearing.rvs">[docs]</a>    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">StateVector</span><span class="p">,</span> <span class="n">StateVectors</span><span class="p">]:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Elevation</span><span class="p">(</span><span class="mf">0.</span><span class="p">)],</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="mf">0.</span><span class="p">)]])</span> <span class="o">+</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="Cartesian2DToBearing"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.Cartesian2DToBearing">[docs]</a><span class="k">class</span> <span class="nc">Cartesian2DToBearing</span><span class="p">(</span><span class="n">NonLinearGaussianMeasurement</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is a class implementation of a time-invariant measurement model, where measurements \</span>
<span class="sd">    are assumed to be received in the form of bearing (:math:`\phi`) with Gaussian noise.</span>

<span class="sd">    The model is described by the following equations:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \phi_t = h(\vec{x}_t, v_t)</span>

<span class="sd">    * :math:`h` is a non-linear model function of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      h(\vec{x}_t,v_t) = atan2(\mathcal{y},\mathcal{x}) + v_t</span>

<span class="sd">    * :math:`v_t` is Gaussian distributed with covariance :math:`R`, i.e.:</span>

<span class="sd">    .. math::</span>

<span class="sd">      v_t \sim \mathcal{N}(0,\sigma_{\phi}^2)</span>

<span class="sd">    The :py:attr:`mapping` property of the model is a 2 element vector, whose first \</span>
<span class="sd">    (i.e. :py:attr:`mapping[0]`) and second (i.e. :py:attr:`mapping[1]`) elements contain the \</span>
<span class="sd">    state index of the :math:`x` and :math:`y` coordinates, respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa:E501</span>

    <span class="n">translation_offset</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 2x1 array specifying the origin offset in terms of :math:`x,y` coordinates.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that the translation offset is initiated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Set values to defaults if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ndim_meas getter method</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            :class:`int`</span>
<span class="sd">                The number of measurement dimensions</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

<div class="viewcode-block" id="Cartesian2DToBearing.function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.Cartesian2DToBearing.function">[docs]</a>    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model function :math:`h(\vec{x}_t,v_t)`</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            state: :class:`~.State`</span>
<span class="sd">                An input state</span>
<span class="sd">            noise: :class:`numpy.ndarray` or bool</span>
<span class="sd">                An externally generated random process noise sample (the default is `False`, in</span>
<span class="sd">                which case no noise will be added.</span>
<span class="sd">                If &#39;True&#39;, the output of :meth:`~.Model.rvs` is added)</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            :class:`numpy.ndarray` of shape (:py:attr:`~ndim_state`, 1)</span>
<span class="sd">                The model function evaluated given the provided time interval.</span>
<span class="sd">            &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Account for origin offset</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">])</span>

        <span class="c1"># Rotate coordinates</span>
        <span class="n">xyz_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span> <span class="o">@</span> <span class="n">xyz</span>

        <span class="c1"># Covert to polar</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2pol</span><span class="p">(</span><span class="o">*</span><span class="n">xyz_rot</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">bearings</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phi</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">StateVectors</span><span class="p">([</span><span class="n">bearings</span><span class="p">])</span> <span class="o">+</span> <span class="n">noise</span></div>

<div class="viewcode-block" id="Cartesian2DToBearing.rvs"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.Cartesian2DToBearing.rvs">[docs]</a>    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">StateVector</span><span class="p">,</span> <span class="n">StateVectors</span><span class="p">]:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Bearing</span><span class="p">(</span><span class="mf">0.</span><span class="p">)]])</span> <span class="o">+</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="CartesianToBearingRangeRate"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToBearingRangeRate">[docs]</a><span class="k">class</span> <span class="nc">CartesianToBearingRangeRate</span><span class="p">(</span><span class="n">NonLinearGaussianMeasurement</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is a class implementation of a time-invariant measurement model, \</span>
<span class="sd">    where measurements are assumed to be received in the form of bearing \</span>
<span class="sd">    (:math:`\phi`), range (:math:`r`) and range-rate (:math:`\dot{r}`),</span>
<span class="sd">    with Gaussian noise in each dimension.</span>

<span class="sd">    The model is described by the following equations:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = h(\vec{x}_t, \vec{v}_t)</span>

<span class="sd">    where:</span>

<span class="sd">    * :math:`\vec{y}_t` is a measurement vector of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = \begin{bmatrix}</span>
<span class="sd">                \phi \\</span>
<span class="sd">                r \\</span>
<span class="sd">                \dot{r}</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    * :math:`h` is a non-linear model function of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      h(\vec{x}_t,\vec{v}_t) = \begin{bmatrix}</span>
<span class="sd">                atan2(\mathcal{y},\mathcal{x}) \\</span>
<span class="sd">                \sqrt{\mathcal{x}^2 + \mathcal{y}^2} \\</span>
<span class="sd">                (x\dot{x} + y\dot{y})/\sqrt{x^2 + y^2}</span>
<span class="sd">                \end{bmatrix} + \vec{v}_t</span>

<span class="sd">    * :math:`\vec{v}_t` is Gaussian distributed with covariance</span>
<span class="sd">      :math:`R`, i.e.:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{v}_t \sim \mathcal{N}(0,R)</span>

<span class="sd">    .. math::</span>

<span class="sd">      R = \begin{bmatrix}</span>
<span class="sd">            \sigma_{\phi}^2 &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; \sigma_{r}^2 &amp; 0 \\</span>
<span class="sd">            0 &amp; 0 &amp; \sigma_{\dot{r}}^2</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    The :py:attr:`mapping` property of the model is a 3 element vector, \</span>
<span class="sd">    whose first (i.e. :py:attr:`mapping[0]`), second (i.e. \</span>
<span class="sd">    :py:attr:`mapping[1]`) and third (i.e. :py:attr:`mapping[2]`) elements \</span>
<span class="sd">    contain the state index of the :math:`x`, :math:`y` and :math:`z`  \</span>
<span class="sd">    coordinates, respectively.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implementation assuming at 3D cartesian space, it therefore \</span>
<span class="sd">    expects a 6D state space.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">translation_offset</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 3x1 array specifying the origin offset in terms of :math:`x,y` coordinates.&quot;</span><span class="p">)</span>
    <span class="n">velocity_mapping</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Mapping to the targets velocity within its state space&quot;</span><span class="p">)</span>
    <span class="n">velocity</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 3x1 array specifying the sensor velocity in terms of :math:`x,y,z` coordinates.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that the translation offset is initiated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Set values to defaults if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;ndim_meas getter method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`int`</span>
<span class="sd">            The number of measurement dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">3</span>

<div class="viewcode-block" id="CartesianToBearingRangeRate.function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToBearingRangeRate.function">[docs]</a>    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model function :math:`h(\vec{x}_t,\vec{v}_t)`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state: :class:`~.State`</span>
<span class="sd">            An input state</span>
<span class="sd">        noise: :class:`numpy.ndarray` or bool</span>
<span class="sd">            An externally generated random process noise sample (the default is</span>
<span class="sd">            `False`, in which case no noise will be added</span>
<span class="sd">            if &#39;True&#39;, the output of :meth:`~.Model.rvs` is added)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.ndarray` of shape (:py:attr:`~ndim_state`, 1)</span>
<span class="sd">            The model function evaluated given the provided time interval.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Account for origin offset in position to enable range and angles to be determined</span>
        <span class="n">xy_pos</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span>

        <span class="c1"># Rotate coordinates based upon the sensor_velocity</span>
        <span class="n">xy_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span> <span class="o">@</span> <span class="n">xy_pos</span>

        <span class="c1"># Convert to Spherical</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cart2sphere</span><span class="p">(</span><span class="n">xy_rot</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xy_rot</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xy_rot</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Determine the net velocity component in the engagement</span>
        <span class="n">xy_vel</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span>

        <span class="c1"># Use polar to calculate range rate</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;j&#39;</span><span class="p">,</span> <span class="n">xy_pos</span><span class="p">,</span> <span class="n">xy_vel</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Convert to bearings</span>
        <span class="n">bearings</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phi</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">StateVectors</span><span class="p">([</span><span class="n">bearings</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rr</span><span class="p">])</span> <span class="o">+</span> <span class="n">noise</span></div>

<div class="viewcode-block" id="CartesianToBearingRangeRate.rvs"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToBearingRangeRate.rvs">[docs]</a>    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">StateVector</span><span class="p">,</span> <span class="n">StateVectors</span><span class="p">]:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Bearing</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]])</span> <span class="o">+</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="CartesianToElevationBearingRangeRate"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearingRangeRate">[docs]</a><span class="k">class</span> <span class="nc">CartesianToElevationBearingRangeRate</span><span class="p">(</span><span class="n">NonLinearGaussianMeasurement</span><span class="p">,</span> <span class="n">ReversibleModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is a class implementation of a time-invariant measurement model, \</span>
<span class="sd">    where measurements are assumed to be received in the form of elevation \</span>
<span class="sd">    (:math:`\theta`),  bearing (:math:`\phi`), range (:math:`r`) and</span>
<span class="sd">    range-rate (:math:`\dot{r}`), with Gaussian noise in each dimension.</span>

<span class="sd">    The model is described by the following equations:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = h(\vec{x}_t, \vec{v}_t)</span>

<span class="sd">    where:</span>

<span class="sd">    * :math:`\vec{y}_t` is a measurement vector of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = \begin{bmatrix}</span>
<span class="sd">                \theta \\</span>
<span class="sd">                \phi \\</span>
<span class="sd">                r \\</span>
<span class="sd">                \dot{r}</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    * :math:`h` is a non-linear model function of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      h(\vec{x}_t,\vec{v}_t) = \begin{bmatrix}</span>
<span class="sd">                asin(\mathcal{z}/\sqrt{\mathcal{x}^2 + \mathcal{y}^2 +\mathcal{z}^2}) \\</span>
<span class="sd">                atan2(\mathcal{y},\mathcal{x}) \\</span>
<span class="sd">                \sqrt{\mathcal{x}^2 + \mathcal{y}^2 + \mathcal{z}^2} \\</span>
<span class="sd">                (x\dot{x} + y\dot{y} + z\dot{z})/\sqrt{x^2 + y^2 + z^2}</span>
<span class="sd">                \end{bmatrix} + \vec{v}_t</span>

<span class="sd">    * :math:`\vec{v}_t` is Gaussian distributed with covariance :math:`R`, i.e.:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{v}_t \sim \mathcal{N}(0,R)</span>

<span class="sd">    .. math::</span>

<span class="sd">      R = \begin{bmatrix}</span>
<span class="sd">            \sigma_{\theta}^2 &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; \sigma_{\phi}^2 &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; \sigma_{r}^2 &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; 0 &amp; \sigma_{\dot{r}}^2</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    The :py:attr:`mapping` property of the model is a 3 element vector, \</span>
<span class="sd">    whose first (i.e. :py:attr:`mapping[0]`), second (i.e. \</span>
<span class="sd">    :py:attr:`mapping[1]`) and third (i.e. :py:attr:`mapping[2]`) elements \</span>
<span class="sd">    contain the state index of the :math:`x`, :math:`y` and :math:`z`  \</span>
<span class="sd">    coordinates, respectively.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implementation assuming at 3D cartesian space, it therefore \</span>
<span class="sd">    expects a 6D state space.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">translation_offset</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 3x1 array specifying the origin offset in terms of :math:`x,y,z` coordinates.&quot;</span><span class="p">)</span>
    <span class="n">velocity_mapping</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Mapping to the targets velocity within its state space&quot;</span><span class="p">)</span>
    <span class="n">velocity</span><span class="p">:</span> <span class="n">StateVector</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A 3x1 array specifying the sensor velocity in terms of :math:`x,y,z` coordinates.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that the translation offset is initiated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Set values to defaults if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;ndim_meas getter method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`int`</span>
<span class="sd">            The number of measurement dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">4</span>

<div class="viewcode-block" id="CartesianToElevationBearingRangeRate.function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearingRangeRate.function">[docs]</a>    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model function :math:`h(\vec{x}_t,\vec{v}_t)`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state: :class:`~.StateVector`</span>
<span class="sd">            An input state vector for the target</span>

<span class="sd">        noise: :class:`numpy.ndarray` or bool</span>
<span class="sd">            An externally generated random process noise sample (the default is</span>
<span class="sd">            `False`, in which case no noise will be added</span>
<span class="sd">            if &#39;True&#39;, the output of :meth:`~.Model.rvs` is added)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.ndarray` of shape (:py:attr:`~ndim_state`, 1)</span>
<span class="sd">            The model function evaluated given the provided time interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Account for origin offset in position to enable range and angles to be determined</span>
        <span class="n">xyz_pos</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span>

        <span class="c1"># Rotate coordinates based upon the sensor_velocity</span>
        <span class="n">xyz_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span> <span class="o">@</span> <span class="n">xyz_pos</span>

        <span class="c1"># Convert to Spherical</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">cart2sphere</span><span class="p">(</span><span class="n">xyz_rot</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xyz_rot</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xyz_rot</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Determine the net velocity component in the engagement</span>
        <span class="n">xyz_vel</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span>

        <span class="c1"># Use polar to calculate range rate</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;j&#39;</span><span class="p">,</span> <span class="n">xyz_pos</span><span class="p">,</span> <span class="n">xyz_vel</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xyz_pos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">bearings</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phi</span><span class="p">]</span>
        <span class="n">elevations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Elevation</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">theta</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">StateVectors</span><span class="p">([</span><span class="n">elevations</span><span class="p">,</span>
                             <span class="n">bearings</span><span class="p">,</span>
                             <span class="n">rho</span><span class="p">,</span>
                             <span class="n">rr</span><span class="p">])</span> <span class="o">+</span> <span class="n">noise</span></div>

<div class="viewcode-block" id="CartesianToElevationBearingRangeRate.inverse_function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearingRangeRate.inverse_function">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detection</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StateVector</span><span class="p">:</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_rate</span> <span class="o">=</span> <span class="n">detection</span><span class="o">.</span><span class="n">state_vector</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sphere2cart</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="c1"># because only rho_rate is known, only the components in</span>
        <span class="c1"># x,y and z of the range rate can be found.</span>
        <span class="n">x_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho_rate</span>
        <span class="n">y_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho_rate</span>
        <span class="n">z_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho_rate</span>

        <span class="n">inv_rotation_matrix</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">)</span>

        <span class="n">out_vector</span> <span class="o">=</span> <span class="n">StateVector</span><span class="p">([[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]])</span>
        <span class="n">out_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
        <span class="n">out_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_rate</span><span class="p">,</span> <span class="n">y_rate</span><span class="p">,</span> <span class="n">z_rate</span>

        <span class="n">out_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">inv_rotation_matrix</span> <span class="o">@</span> <span class="n">out_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">out_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
            <span class="n">inv_rotation_matrix</span> <span class="o">@</span> <span class="n">out_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_mapping</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">out_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">out_vector</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation_offset</span>

        <span class="k">return</span> <span class="n">out_vector</span></div>

<div class="viewcode-block" id="CartesianToElevationBearingRangeRate.rvs"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.CartesianToElevationBearingRangeRate.rvs">[docs]</a>    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">StateVector</span><span class="p">,</span> <span class="n">StateVectors</span><span class="p">]:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Elevation</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="n">Bearing</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]])</span> <span class="o">+</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="RangeRangeRateBinning"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.RangeRangeRateBinning">[docs]</a><span class="k">class</span> <span class="nc">RangeRangeRateBinning</span><span class="p">(</span><span class="n">CartesianToElevationBearingRangeRate</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is a class implementation of a time-invariant measurement model, \</span>
<span class="sd">    where measurements are assumed to be in the form of elevation \</span>
<span class="sd">    (:math:`\theta`),  bearing (:math:`\phi`), range (:math:`r`) and</span>
<span class="sd">    range-rate (:math:`\dot{r}`), with Gaussian noise in each dimension and the</span>
<span class="sd">    range and range-rate are binned based on the</span>
<span class="sd">    range resolution and range-rate resolution respectively.</span>

<span class="sd">    The model is described by the following equations:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = h(\vec{x}_t, \vec{v}_t)</span>

<span class="sd">    where:</span>

<span class="sd">    * :math:`\vec{y}_t` is a measurement vector of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{y}_t = \begin{bmatrix}</span>
<span class="sd">                \theta \\</span>
<span class="sd">                \phi \\</span>
<span class="sd">                r \\</span>
<span class="sd">                \dot{r}</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    * :math:`h` is a non-linear model function of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">      h(\vec{x}_t,\vec{v}_t) = \begin{bmatrix}</span>
<span class="sd">                \textrm{asin}(\mathcal{z}/\sqrt{\mathcal{x}^2 + \mathcal{y}^2 +\mathcal{z}^2}) \\</span>
<span class="sd">                \textrm{atan2}(\mathcal{y},\mathcal{x}) \\</span>
<span class="sd">                \sqrt{\mathcal{x}^2 + \mathcal{y}^2 + \mathcal{z}^2} \\</span>
<span class="sd">                (x\dot{x} + y\dot{y} + z\dot{z})/\sqrt{x^2 + y^2 + z^2}</span>
<span class="sd">                \end{bmatrix} + \vec{v}_t</span>

<span class="sd">    * :math:`\vec{v}_t` is Gaussian distributed with covariance :math:`R`, i.e.:</span>

<span class="sd">    .. math::</span>

<span class="sd">      \vec{v}_t \sim \mathcal{N}(0,R)</span>

<span class="sd">    .. math::</span>

<span class="sd">      R = \begin{bmatrix}</span>
<span class="sd">            \sigma_{\theta}^2 &amp; 0 &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; \sigma_{\phi}^2 &amp; 0 &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; \sigma_{r}^2 &amp; 0\\</span>
<span class="sd">            0 &amp; 0 &amp; 0 &amp; \sigma_{\dot{r}}^2</span>
<span class="sd">            \end{bmatrix}</span>

<span class="sd">    The covariances for radar are determined by different factors. The angle error</span>
<span class="sd">    is affected by the radar beam width. Range error is affected by the SNR and pulse bandwidth.</span>
<span class="sd">    The error for the range rate is dependent on the dwell time.</span>
<span class="sd">    The range and range rate are binned to the centre of the cell using</span>

<span class="sd">    .. math::</span>

<span class="sd">        x = \textrm{floor}(x/\Delta x)*\Delta x + \frac{\Delta x}{2}</span>

<span class="sd">    The :py:attr:`mapping` property of the model is a 3 element vector, \</span>
<span class="sd">    whose first (i.e. :py:attr:`mapping[0]`), second (i.e. \</span>
<span class="sd">    :py:attr:`mapping[1]`) and third (i.e. :py:attr:`mapping[2]`) elements \</span>
<span class="sd">    contain the state index of the :math:`x`, :math:`y` and :math:`z`  \</span>
<span class="sd">    coordinates, respectively.</span>

<span class="sd">    The :py:attr:`velocity_mapping` property of the model is a 3 element vector, \</span>
<span class="sd">    whose first (i.e. :py:attr:`velocity_mapping[0]`), second (i.e. \</span>
<span class="sd">    :py:attr:`velocity_mapping[1]`) and third (i.e. :py:attr:`velocity_mapping[2]`) elements \</span>
<span class="sd">    contain the state index of the :math:`\dot{x}`, :math:`\dot{y}` and :math:`\dot{z}`  \</span>
<span class="sd">    coordinates, respectively.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class implementation assumes a 3D cartesian space, it therefore \</span>
<span class="sd">    expects a 6D state space.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">range_res</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Size of the range bins in m&quot;</span><span class="p">)</span>
    <span class="n">range_rate_res</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Size of the velocity bins in m/s&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim_meas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">4</span>

<div class="viewcode-block" id="RangeRangeRateBinning.function"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.RangeRangeRateBinning.function">[docs]</a>    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model function :math:`h(\vec{x}_t,\vec{v}_t)`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state: :class:`~.StateVector`</span>
<span class="sd">            An input state vector for the target</span>

<span class="sd">        noise: :class:`numpy.ndarray` or bool</span>
<span class="sd">            An externally generated random process noise sample (the default is</span>
<span class="sd">            ``False``, in which case no noise will be added and no binning takes place</span>
<span class="sd">            if ``True``, the output of :attr:`~.Model.rvs` is added and the</span>
<span class="sd">            range and range rate are binned)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.ndarray` of shape (:py:attr:`~ndim_state`, 1)</span>
<span class="sd">            The model function evaluated given the provided time interval.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_res</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_res</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_rate_res</span><span class="p">)</span> <span class="o">*</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">range_rate_res</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_rate_res</span><span class="o">/</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">out</span></div>

    <span class="k">def</span> <span class="nf">_gaussian_integral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
        <span class="c1"># this function is the cumulative probability ranging from a to b for a normal distribution</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">multivariate_normal</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
                <span class="o">-</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_binned_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measured_value</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
        <span class="c1"># this function finds the probability density of the bin the measured_value is in</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">measured_value</span> <span class="o">/</span> <span class="n">bin_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span> <span class="o">+</span> <span class="n">bin_size</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">measured_value</span> <span class="o">/</span> <span class="n">bin_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_size</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_integral</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span><span class="o">/</span><span class="n">bin_size</span>

<div class="viewcode-block" id="RangeRangeRateBinning.pdf"><a class="viewcode-back" href="../../../../smartfusion.models.measurement.html#smartfusion.models.measurement.nonlinear.RangeRangeRateBinning.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model pdf/likelihood evaluation function</span>

<span class="sd">        Evaluates the pdf/likelihood of ``state1``, given the state</span>
<span class="sd">        ``state2`` which is passed to :meth:`function()`.</span>

<span class="sd">        For the first 2 dimensions, this can be written as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            p = p(y_t | x_t) = \mathcal{N}(y_t; x_t, Q)</span>

<span class="sd">        where :math:`y_t` = ``state_vector1``, :math:`x_t` = ``state_vector2``,</span>
<span class="sd">         :math:`Q` = :attr:`covar` and :math:`\mathcal{N}` is a normal distribution</span>

<span class="sd">        The probability for the binned dimensions, the last 2, can be written as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            p = P(a \leq \mathcal{N} \leq b)</span>

<span class="sd">        In this equation a and b are the edges of the bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state1 : :class:`~.State`</span>
<span class="sd">        state2 : :class:`~.State`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : :class:`~.Probability`</span>
<span class="sd">            The likelihood of ``state1``, given ``state2``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># state1 is in measurement space</span>
        <span class="c1"># state2 is in state_space</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">state1</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">range_res</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_res</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
                <span class="ow">and</span> <span class="p">((</span><span class="n">state1</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">range_rate_res</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">range_rate_res</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()):</span>
            <span class="n">mean_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">state2</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># pdf for the angles</span>
            <span class="n">az_el_pdf</span> <span class="o">=</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span>
                <span class="n">state1</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">mean</span><span class="o">=</span><span class="n">mean_vector</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">covar</span><span class="p">()[:</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># pdf for the binned range and velocity</span>
            <span class="n">range_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binned_pdf</span><span class="p">(</span>
                <span class="n">state1</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">mean_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">range_res</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">covar</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">velocity_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binned_pdf</span><span class="p">(</span>
                <span class="n">state1</span><span class="o">.</span><span class="n">state_vector</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">mean_vector</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">range_rate_res</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">covar</span><span class="p">()[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Probability</span><span class="p">(</span><span class="n">range_pdf</span> <span class="o">*</span> <span class="n">velocity_pdf</span> <span class="o">*</span> <span class="n">az_el_pdf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Probability</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../../../copyright.html">Copyright</a> 2017-2022 SMART FUSION contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>