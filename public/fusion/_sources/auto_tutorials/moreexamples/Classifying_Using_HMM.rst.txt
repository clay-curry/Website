
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/moreexamples/Classifying_Using_HMM.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_tutorials_moreexamples_Classifying_Using_HMM.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_moreexamples_Classifying_Using_HMM.py:


Classification Using Hidden Markov Model
========================================
This is a demonstration using the implemented forward algorithm in the context of a hidden Markov
model to classify multiple targets.

We will attempt to classify 3 targets in an undefined region.

.. GENERATED FROM PYTHON SOURCE LINES 13-14

All SMART FUSION imports will be given in order of usage.

.. GENERATED FROM PYTHON SOURCE LINES 14-23

.. code-block:: default


    from datetime import datetime, timedelta

    import numpy as np

    from smartfusion.models.transition.categorical import MarkovianTransitionModel
    from smartfusion.types.groundtruth import CategoricalGroundTruthState
    from smartfusion.types.groundtruth import GroundTruthPath








.. GENERATED FROM PYTHON SOURCE LINES 24-50

Ground Truth
^^^^^^^^^^^^
The targets may take one of two discrete hidden classes: 'bike', and 'car'.
A target may be able to transition from one class to another (this could be considered as a
person switching from riding a bike to driving a car and vice versa).
This behaviour will be modelled in the transition matrix of the
:class:`~.MarkovianTransitionModel`. This transition matrix is a Markov process matrix, whereby
it is assumed that the state of a target is wholly dependent on its previous state, and nothing
else.

A :class:`~.CategoricalState` class is used to store information on the classification/category
of the targets. The state vector will define a categorical distribution over the 2 possible
classes, whereby each component defines the probability that a target is of the corresponding
class. For example, the state vector (0.2, 0.8), with category names ('bike', 'car')
indicates that a target has a 20% probability of being class 'bike' and an 80% probability of
being class 'car' etc.
It does not make sense to have a true target being a distribution over the possible classes, and
therefore the true categorical states will have binary state vectors indicating a specific class
(i.e. a '1' at one state vector index, and '0's elsewhere). This can be considered as stating
there is a 100% probability that the target is of a particular class. We specify that there
should be noise when functioning our transition model in order to sample the resultant
distribution and receive this binary vector.
The :class:`~.CategoricalGroundTruthState` class inherits directly from the base
:class:`~.CategoricalState` class.

The category and timings for one of the ground truth paths will be printed.

.. GENERATED FROM PYTHON SOURCE LINES 50-89

.. code-block:: default


    transition_matrix = np.array([[0.8, 0.2],  # P(bike | bike), P(bike | car)
                                  [0.4, 0.6]])  # P(car | bike), P(car | car)
    category_transition = MarkovianTransitionModel(transition_matrix=transition_matrix)

    start = datetime.now()

    hidden_classes = ['bike', 'car']

    # Generating ground truth
    ground_truths = list()
    for i in range(1, 4):  # 4 targets
        state_vector = np.zeros(2)  # create a vector with 2 zeroes
        state_vector[np.random.choice(2, 1, p=[1 / 2, 1 / 2])] = 1  # pick a random class out of the 2
        ground_truth_state = CategoricalGroundTruthState(state_vector,
                                                         timestamp=start,
                                                         categories=hidden_classes)

        ground_truth = GroundTruthPath([ground_truth_state], id=f"GT{i}")

        for _ in range(10):
            new_vector = category_transition.function(ground_truth[-1],
                                                      noise=True,
                                                      time_interval=timedelta(seconds=1))
            new_state = CategoricalGroundTruthState(
                new_vector,
                timestamp=ground_truth[-1].timestamp + timedelta(seconds=1),
                categories=hidden_classes
            )

            ground_truth.append(new_state)
        ground_truths.append(ground_truth)

    for states in np.vstack(ground_truths).T:
        print(f"{states[0].timestamp:%H:%M:%S}", end="")
        for state in states:
            print(f" -- {state.category}", end="")
        print()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    17:25:32 -- bike -- car -- car
    17:25:33 -- bike -- car -- car
    17:25:34 -- bike -- car -- bike
    17:25:35 -- car -- car -- bike
    17:25:36 -- car -- bike -- bike
    17:25:37 -- car -- bike -- car
    17:25:38 -- car -- bike -- car
    17:25:39 -- bike -- bike -- bike
    17:25:40 -- car -- car -- car
    17:25:41 -- car -- car -- car
    17:25:42 -- car -- car -- car




.. GENERATED FROM PYTHON SOURCE LINES 90-100

Measurement
^^^^^^^^^^^
Using a Hidden Markov model, it is assumed the true class of a target cannot be directly
observed (hence 'hidden'), and instead observations that are dependent on this class are taken.
In this instance, observations of the targets' sizes are taken ('small', 'medium' or 'large').
The relationship between true class and observed size is modelled by the `emission matrix` of the
:class:`~.MarkovianMeasurementModel`, which is used by the :class:`~.HMMSensor` to
provide :class:`~.CategoricalDetection` types.
We will model this such that a 'bike' has a very small chance of being observed as a 'big'
target etc.

.. GENERATED FROM PYTHON SOURCE LINES 100-125

.. code-block:: default


    from smartfusion.models.measurement.categorical import MarkovianMeasurementModel
    from smartfusion.sensor.categorical import HMMSensor

    E = np.array([[0.8, 0.1],  # P(small | bike), P(small | car)
                  [0.19, 0.3],  # P(medium | bike), P(medium | car)
                  [0.01, 0.6]])  # P(large | bike), P(large | car)

    model = MarkovianMeasurementModel(emission_matrix=E,
                                      measurement_categories=['small', 'medium', 'large'])

    eo = HMMSensor(measurement_model=model)

    # Generating measurements
    measurements = list()
    for index, states in enumerate(np.vstack(ground_truths).T):
        if index == 5:
            measurements_at_time = set()  # Give tracker chance to use prediction instead
        else:
            measurements_at_time = eo.measure(states)
        timestamp = next(iter(states)).timestamp
        measurements.append((timestamp, measurements_at_time))

        print(f"{timestamp:%H:%M:%S} -- {[meas.category for meas in measurements_at_time]}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    17:25:32 -- ['large', 'small', 'small']
    17:25:33 -- ['medium', 'small', 'large']
    17:25:34 -- ['small', 'small', 'small']
    17:25:35 -- ['large', 'small', 'small']
    17:25:36 -- ['small', 'small', 'medium']
    17:25:37 -- []
    17:25:38 -- ['large', 'small', 'medium']
    17:25:39 -- ['small', 'small', 'small']
    17:25:40 -- ['large', 'medium', 'medium']
    17:25:41 -- ['large', 'large', 'small']
    17:25:42 -- ['large', 'large', 'medium']




.. GENERATED FROM PYTHON SOURCE LINES 126-128

Tracking Components
^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 130-134

Predictor
---------
A :class:`~.HMMPredictor` specifically uses :class:`~.MarkovianTransitionModel` types to
predict.

.. GENERATED FROM PYTHON SOURCE LINES 134-143

.. code-block:: default

    from smartfusion.predictor.categorical import HMMPredictor

    # It would be cheating to use the same transition model as in ground truth generation!
    transition_matrix = np.array([[0.81, 0.19],  # P(bike | bike), P(bike | car)
                                  [0.39, 0.61]])  # P(car | bike), P(car | car)
    category_transition = MarkovianTransitionModel(transition_matrix=transition_matrix)

    predictor = HMMPredictor(category_transition)








.. GENERATED FROM PYTHON SOURCE LINES 144-146

Updater
-------

.. GENERATED FROM PYTHON SOURCE LINES 146-150

.. code-block:: default

    from smartfusion.updater.categorical import HMMUpdater

    updater = HMMUpdater()








.. GENERATED FROM PYTHON SOURCE LINES 151-157

Hypothesiser
------------
A :class:`~.HMMHypothesiser` is used for calculating categorical hypotheses.
It utilises the :class:`~.ObservationAccuracy` measure: a multi-dimensional extension of an
'accuracy' score, essentially providing a measure of the similarity between two categorical
distributions.

.. GENERATED FROM PYTHON SOURCE LINES 157-161

.. code-block:: default

    from smartfusion.hypothesiser.categorical import HMMHypothesiser

    hypothesiser = HMMHypothesiser(predictor=predictor, updater=updater)








.. GENERATED FROM PYTHON SOURCE LINES 162-165

Data Associator
---------------
We will use a standard :class:`~.GNNWith2DAssignment` data associator.

.. GENERATED FROM PYTHON SOURCE LINES 165-169

.. code-block:: default

    from smartfusion.dataassociator.neighbour import GNNWith2DAssignment

    data_associator = GNNWith2DAssignment(hypothesiser)








.. GENERATED FROM PYTHON SOURCE LINES 170-175

Prior
-----
As we are tracking in a categorical state space, we should initiate with a categorical state for
the prior. Equal probability is given to all 3 of the possible hidden classes that a target
might take (the category names are also provided here).

.. GENERATED FROM PYTHON SOURCE LINES 175-179

.. code-block:: default

    from smartfusion.types.state import CategoricalState

    prior = CategoricalState([1 / 2, 1 / 2], categories=hidden_classes)








.. GENERATED FROM PYTHON SOURCE LINES 180-185

Initiator
---------
For each unassociated detection, a new track will be initiated. In this instance we use a
:class:`~.SimpleCategoricalMeasurementInitiator`, which specifically handles categorical state
priors.

.. GENERATED FROM PYTHON SOURCE LINES 185-189

.. code-block:: default

    from smartfusion.initiator.categorical import SimpleCategoricalMeasurementInitiator

    initiator = SimpleCategoricalMeasurementInitiator(prior_state=prior, updater=updater)








.. GENERATED FROM PYTHON SOURCE LINES 190-193

Deleter
-------
We can use a standard :class:`~.UpdateTimeStepsDeleter`.

.. GENERATED FROM PYTHON SOURCE LINES 193-197

.. code-block:: default

    from smartfusion.deleter.time import UpdateTimeStepsDeleter

    deleter = UpdateTimeStepsDeleter(2)








.. GENERATED FROM PYTHON SOURCE LINES 198-201

Tracker
-------
We can use a standard :class:`~.MultiTargetTracker`.

.. GENERATED FROM PYTHON SOURCE LINES 201-205

.. code-block:: default

    from smartfusion.tracker.simple import MultiTargetTracker

    tracker = MultiTargetTracker(initiator, deleter, measurements, data_associator, updater)








.. GENERATED FROM PYTHON SOURCE LINES 206-208

Tracking
^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 208-230

.. code-block:: default


    tracks = set()
    for time, ctracks in tracker:
        tracks.update(ctracks)

    print(f"Number of tracks: {len(tracks)}")
    for track in tracks:
        certainty = track.state_vector[np.argmax(track.state_vector)][0] * 100
        print(f"id: {track.id} -- category: {track.category} -- certainty: {certainty}%")
        for state in track:
            _time = state.timestamp.strftime('%H:%M')
            _type = str(type(state)).replace("class 'smartfusion.types.", "").strip("<>'. ")
            state_string = f"{_time} -- {_type} -- {state.category}"
            try:
                meas_string = f"associated measurement: {state.hypothesis.measurement.category}"
            except AttributeError:
                pass
            else:
                state_string += f" -- {meas_string}"
            print(state_string)
        print()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of tracks: 3
    id: 8f5c2eb6-61e5-4696-8bcf-a01bb5fa585e -- category: bike -- certainty: 50.952841595191344%
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- prediction.CategoricalStatePrediction -- bike
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: medium
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: medium

    id: e5867d15-a2cf-469b-afe8-4682dfabb82e -- category: car -- certainty: 99.47681125825135%
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: medium
    17:25 -- prediction.CategoricalStatePrediction -- car
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large

    id: 28d2f0a1-4018-4461-9da8-203912b12cfe -- category: car -- certainty: 99.46638630863406%
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: medium
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- prediction.CategoricalStatePrediction -- bike
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: medium
    17:25 -- update.CategoricalStateUpdate -- bike -- associated measurement: small
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: medium
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large
    17:25 -- update.CategoricalStateUpdate -- car -- associated measurement: large





.. GENERATED FROM PYTHON SOURCE LINES 231-237

Metric
^^^^^^
Determining tracking accuracy.
In calculating how many targets were classified correctly, only tracks with the highest
classification certainty are considered. In the situation where probabilities are equal, a
random classification is chosen.

.. GENERATED FROM PYTHON SOURCE LINES 237-257

.. code-block:: default


    excess_tracks = len(tracks) - len(ground_truths)  # target value = 0
    sorted_tracks = sorted(tracks,
                           key=lambda track: track.state_vector[np.argmax(track.state_vector)][0],
                           reverse=True)
    best_tracks = sorted_tracks[:3]
    true_classifications = [ground_truth.category for ground_truth in ground_truths]
    track_classifications = [track.category for track in best_tracks]

    num_correct_classifications = 0  # target value = num ground truths
    for true_classification in true_classifications:
        for i in range(len(track_classifications)):
            if track_classifications[i] == true_classification:
                num_correct_classifications += 1
                del track_classifications[i]
                break

    print(f"Excess tracks: {excess_tracks}")
    print(f"No. correct classifications: {num_correct_classifications}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Excess tracks: 0
    No. correct classifications: 2




.. GENERATED FROM PYTHON SOURCE LINES 258-264

Plotting
^^^^^^^^
Plotting the probability that each one of our targets and tracks is a 'bike' will help to
visualise this 2-hidden class problem.

Dotted lines indicate ground truth probabilities, and solid lines for tracks.

.. GENERATED FROM PYTHON SOURCE LINES 264-281

.. code-block:: default


    import matplotlib.pyplot as plt


    def plot(path, style):
        times = list()
        probs = list()
        for state in path:
            times.append(state.timestamp)
            probs.append(state.state_vector[0])
        plt.plot(times, probs, linestyle=style)


    for truth in ground_truths:
        plot(truth, '--')
    for track in tracks:
        plot(track, '-')



.. image-sg:: /auto_tutorials/moreexamples/images/sphx_glr_Classifying_Using_HMM_001.png
   :alt: Classifying Using HMM
   :srcset: /auto_tutorials/moreexamples/images/sphx_glr_Classifying_Using_HMM_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.060 seconds)


.. _sphx_glr_download_auto_tutorials_moreexamples_Classifying_Using_HMM.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/claycurry34/Smart-Fusion/main?filepath=notebooks/auto_tutorials/moreexamples/Classifying_Using_HMM.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: Classifying_Using_HMM.py <Classifying_Using_HMM.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: Classifying_Using_HMM.ipynb <Classifying_Using_HMM.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
