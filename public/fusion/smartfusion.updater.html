<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Updaters &mdash; SMART FUSION 0.1b11.dev6+g9121db30.d20220926 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="Data Types" href="smartfusion.types.html" />
    <link rel="prev" title="Smoothers" href="smartfusion.smoother.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> SMART FUSION
            <img src="_static/smart_fusion_logo.jpeg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.1b11.dev6+g9121db30.d20220926
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="design.html">Framework </a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="smartfusion.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="interface.html">Component Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Base Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="smartfusion.base.html">Declarative Base</a></li>
<li class="toctree-l2"><a class="reference internal" href="smartfusion.config.html">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="smartfusion.functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="smartfusion.measures.html">Measures</a></li>
<li class="toctree-l2"><a class="reference internal" href="smartfusion.plotter.html">Plotter</a></li>
<li class="toctree-l2"><a class="reference internal" href="smartfusion.plugins.html">Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="smartfusion.serialise.html">Serialisation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="smartfusion.html#components">Components</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="smartfusion.html#enabling-components">Enabling Components</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="smartfusion.html#algorithm-components">Algorithm Components</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="smartfusion.dataassociator.html">Data Association</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.deleter.html">Deleters</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.gater.html">Gater</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.hypothesiser.html">Hypothesiser</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.initiator.html">Initiators</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.mixturereducer.html">Mixture Reducers</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.models.html">Models</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.predictor.html">Predictors</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.resampler.html">Resampler</a></li>
<li class="toctree-l4"><a class="reference internal" href="smartfusion.smoother.html">Smoothers</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Updaters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="smartfusion.html#data-types">Data Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="auto_demos/index.html">Demonstrations</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright &amp; License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SMART FUSION</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="smartfusion.html">Documentation</a> &raquo;</li>
      <li>Updaters</li>
  
  <li class="wy-breadcrumbs-aside">
    <a href="https://github.com/claycurry34/Smart-Fusion/blob/main/docs/source/smartfusion.updater.rst" class="fa fa-github"> Edit on GitHub</a>
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-smartfusion.updater">
<span id="updaters"></span><h1>Updaters<a class="headerlink" href="#module-smartfusion.updater" title="Permalink to this heading"></a></h1>
<span class="target" id="module-smartfusion.updater.base"></span><dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.base.Updater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.base.</span></span><span class="sig-name descname"><span class="pre">Updater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/base.html#Updater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.base.Updater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="smartfusion.base.html#smartfusion.base.Base" title="smartfusion.base.Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Base</span></code></a></p>
<p>Updater base class</p>
<p>An updater is used to update the predicted state, utilising a measurement
and a <a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>.  The general observation model is</p>
<div class="math notranslate nohighlight">
\[\mathbf{z} = h(\mathbf{x}, \mathbf{\sigma})\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is the state, <span class="math notranslate nohighlight">\(\mathbf{\sigma}\)</span>, the
measurement noise and <span class="math notranslate nohighlight">\(\mathbf{z}\)</span> the resulting measurement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – measurement model</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.base.Updater.measurement_model">
<span class="sig-name descname"><span class="pre">measurement_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></em><a class="headerlink" href="#smartfusion.updater.base.Updater.measurement_model" title="Permalink to this definition"></a></dt>
<dd><p>measurement model</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.base.Updater.predict_measurement">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_prediction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/base.html#Updater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.base.Updater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Get measurement prediction from state prediction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_prediction</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.StatePrediction" title="smartfusion.types.prediction.StatePrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">StatePrediction</span></code></a>) – The state prediction</p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – The measurement model used to generate the measurement prediction.
Should be used in cases where the measurement model is dependent
on the received measurement. The default is <cite>None</cite>, in which case
the updater will use the measurement model specified on
initialisation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The predicted measurement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.MeasurementPrediction" title="smartfusion.types.prediction.MeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementPrediction</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.base.Updater.update">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/base.html#Updater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.base.Updater.update" title="Permalink to this definition"></a></dt>
<dd><p>Update state using prediction and measurement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.Hypothesis" title="smartfusion.types.hypothesis.Hypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hypothesis</span></code></a>) – Hypothesis with predicted state and associated detection used for
updating.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The state posterior</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.State" title="smartfusion.types.state.State"><code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<section id="module-smartfusion.updater.kalman">
<span id="kalman"></span><h2>Kalman<a class="headerlink" href="#module-smartfusion.updater.kalman" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.KalmanUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.kalman.</span></span><span class="sig-name descname"><span class="pre">KalmanUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><span class="pre">LinearGaussian</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#KalmanUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.KalmanUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><code class="xref py py-class docutils literal notranslate"><span class="pre">Updater</span></code></a></p>
<p>A class which embodies Kalman-type updaters; also a class which
performs measurement update step as in the standard Kalman Filter.</p>
<p>The Kalman updaters assume <span class="math notranslate nohighlight">\(h(\mathbf{x}) = H \mathbf{x}\)</span> with
additive noise <span class="math notranslate nohighlight">\(\sigma = \mathcal{N}(0,R)\)</span>. Daughter classes can
overwrite to specify a more general measurement model
<span class="math notranslate nohighlight">\(h(\mathbf{x})\)</span>.</p>
<p><a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater.update" title="smartfusion.updater.kalman.KalmanUpdater.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> first calls <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater.predict_measurement" title="smartfusion.updater.kalman.KalmanUpdater.predict_measurement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_measurement()</span></code></a> function which
proceeds by calculating the predicted measurement, innovation covariance
and measurement cross-covariance,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{z}_{k|k-1} = H_k \mathbf{x}_{k|k-1}\\S_k = H_k P_{k|k-1} H_k^T + R_k\\\Upsilon_k = P_{k|k-1} H_k^T\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(P_{k|k-1}\)</span> is the predicted state covariance.
<a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater.predict_measurement" title="smartfusion.updater.kalman.KalmanUpdater.predict_measurement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_measurement()</span></code></a> returns a
<a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.GaussianMeasurementPrediction" title="smartfusion.types.prediction.GaussianMeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianMeasurementPrediction</span></code></a>. The Kalman gain is then
calculated as,</p>
<div class="math notranslate nohighlight">
\[K_k = \Upsilon_k S_k^{-1}\]</div>
<p>and the posterior state mean and covariance are,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{x}_{k|k} = \mathbf{x}_{k|k-1} + K_k (\mathbf{z}_k - H_k
\mathbf{x}_{k|k-1})\\P_{k|k} = P_{k|k-1} - K_k S_k K_k^T\end{aligned}\end{align} \]</div>
<p>These are returned as a <a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.GaussianStateUpdate" title="smartfusion.types.update.GaussianStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianStateUpdate</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearGaussian</span></code></a>, optional) – A linear Gaussian measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.KalmanUpdater.measurement_model">
<span class="sig-name descname"><span class="pre">measurement_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><span class="pre">LinearGaussian</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.KalmanUpdater.measurement_model" title="Permalink to this definition"></a></dt>
<dd><p>A linear Gaussian measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.KalmanUpdater.force_symmetric_covariance">
<span class="sig-name descname"><span class="pre">force_symmetric_covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.KalmanUpdater.force_symmetric_covariance" title="Permalink to this definition"></a></dt>
<dd><p>A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.KalmanUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicted_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#KalmanUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.KalmanUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Predict the measurement implied by the predicted state mean</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predicted_state</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.GaussianState" title="smartfusion.types.state.GaussianState"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianState</span></code></a>) – The predicted state <span class="math notranslate nohighlight">\(\mathbf{x}_{k|k-1}\)</span>, <span class="math notranslate nohighlight">\(P_{k|k-1}\)</span></p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – The measurement model. If omitted, the model in the updater object
is used</p></li>
<li><p><strong>**kwargs</strong> (<em>various</em>) – These are passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">function()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">matrix()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The measurement prediction, <span class="math notranslate nohighlight">\(\mathbf{z}_{k|k-1}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianMeasurementPrediction</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.KalmanUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#KalmanUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.KalmanUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>The Kalman update method. Given a hypothesised association between
a predicted state or predicted measurement and an actual measurement,
calculate the posterior state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.SingleHypothesis" title="smartfusion.types.hypothesis.SingleHypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleHypothesis</span></code></a>) – the prediction-measurement association hypothesis. This hypothesis
may carry a predicted measurement, or a predicted state. In the
latter case a predicted measurement will be calculated.</p></li>
<li><p><strong>**kwargs</strong> (<em>various</em>) – These are passed to <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater.predict_measurement" title="smartfusion.updater.kalman.KalmanUpdater.predict_measurement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_measurement()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The posterior state Gaussian with mean <span class="math notranslate nohighlight">\(\mathbf{x}_{k|k}\)</span> and
covariance <span class="math notranslate nohighlight">\(P_{x|x}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.GaussianStateUpdate" title="smartfusion.types.update.GaussianStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianStateUpdate</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.ExtendedKalmanUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.kalman.</span></span><span class="sig-name descname"><span class="pre">ExtendedKalmanUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#ExtendedKalmanUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.ExtendedKalmanUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a></p>
<p>The Extended Kalman Filter version of the Kalman Updater. Inherits most
of the functionality from <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a>.</p>
<p>The difference is that the measurement model may now be non-linear, though
must be differentiable to return the linearisation of <span class="math notranslate nohighlight">\(h(\mathbf{x})\)</span>
via the matrix <span class="math notranslate nohighlight">\(H\)</span> accessible via <code class="xref py py-meth docutils literal notranslate"><span class="pre">jacobian()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – A measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown. Must be linear or capable or implement the <code class="xref py py-meth docutils literal notranslate"><span class="pre">jacobian()</span></code>.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.ExtendedKalmanUpdater.measurement_model">
<span class="sig-name descname"><span class="pre">measurement_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.ExtendedKalmanUpdater.measurement_model" title="Permalink to this definition"></a></dt>
<dd><p>A measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown. Must be linear or capable or implement the <code class="xref py py-meth docutils literal notranslate"><span class="pre">jacobian()</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.UnscentedKalmanUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.kalman.</span></span><span class="sig-name descname"><span class="pre">UnscentedKalmanUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#UnscentedKalmanUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.UnscentedKalmanUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a></p>
<p>The Unscented Kalman Filter version of the Kalman Updater. Inherits most
of the functionality from <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a>.</p>
<p>In this case the <a class="reference internal" href="#smartfusion.updater.kalman.UnscentedKalmanUpdater.predict_measurement" title="smartfusion.updater.kalman.UnscentedKalmanUpdater.predict_measurement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_measurement()</span></code></a> function uses the
<code class="xref py py-func docutils literal notranslate"><span class="pre">unscented_transform()</span></code> function to estimate a (Gaussian) predicted
measurement. This is then updated via the standard Kalman update equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – The measurement model to be used. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Primary sigma point spread scaling parameter. Default is 0.5.</p></li>
<li><p><strong>beta</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Used to incorporate prior knowledge of the distribution. If the true distribution is Gaussian, the value of 2 is optimal. Default is 2</p></li>
<li><p><strong>kappa</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Secondary spread scaling parameter. Default is calculated as 3-Ns</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.UnscentedKalmanUpdater.measurement_model">
<span class="sig-name descname"><span class="pre">measurement_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.UnscentedKalmanUpdater.measurement_model" title="Permalink to this definition"></a></dt>
<dd><p>The measurement model to be used. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.UnscentedKalmanUpdater.alpha">
<span class="sig-name descname"><span class="pre">alpha</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.UnscentedKalmanUpdater.alpha" title="Permalink to this definition"></a></dt>
<dd><p>Primary sigma point spread scaling parameter. Default is 0.5.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.UnscentedKalmanUpdater.beta">
<span class="sig-name descname"><span class="pre">beta</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.UnscentedKalmanUpdater.beta" title="Permalink to this definition"></a></dt>
<dd><p>Used to incorporate prior knowledge of the distribution. If the true distribution is Gaussian, the value of 2 is optimal. Default is 2</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.UnscentedKalmanUpdater.kappa">
<span class="sig-name descname"><span class="pre">kappa</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.UnscentedKalmanUpdater.kappa" title="Permalink to this definition"></a></dt>
<dd><p>Secondary spread scaling parameter. Default is calculated as 3-Ns</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.UnscentedKalmanUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicted_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#UnscentedKalmanUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.UnscentedKalmanUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Unscented Kalman Filter measurement prediction step. Uses the
unscented transform to estimate a Gauss-distributed predicted
measurement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predicted_state</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.GaussianStatePrediction" title="smartfusion.types.prediction.GaussianStatePrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianStatePrediction</span></code></a>) – A predicted state</p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – The measurement model used to generate the measurement prediction.
This should be used in cases where the measurement model is
dependent on the received measurement (the default is <cite>None</cite>, in
which case the updater will use the measurement model specified on
initialisation)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The measurement prediction</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.GaussianMeasurementPrediction" title="smartfusion.types.prediction.GaussianMeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianMeasurementPrediction</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.SqrtKalmanUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.kalman.</span></span><span class="sig-name descname"><span class="pre">SqrtKalmanUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><span class="pre">LinearGaussian</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qr_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#SqrtKalmanUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.SqrtKalmanUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a></p>
<p>The Square root version of the Kalman Updater.</p>
<p>The input <a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.State" title="smartfusion.types.state.State"><code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code></a> is a <a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.SqrtGaussianState" title="smartfusion.types.state.SqrtGaussianState"><code class="xref py py-class docutils literal notranslate"><span class="pre">SqrtGaussianState</span></code></a> which means
that the covariance of the predicted state is stored in square root form.
This can be achieved by keeping <code class="xref py py-attr docutils literal notranslate"><span class="pre">covar</span></code> attribute as <span class="math notranslate nohighlight">\(L\)</span> where
the ‘full’ covariance matrix <span class="math notranslate nohighlight">\(P_{k|k-1} = L_{k|k-1} L^T_{k|k-1}\)</span>
[Eq1].</p>
<p>In its basic form <span class="math notranslate nohighlight">\(L\)</span> is the lower triangular matrix returned via
Cholesky factorisation. There’s no reason why other forms that satisfy Eq 1
above can’t be used.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Schmidt, S.F. 1970, Computational techniques in Kalman filtering, NATO advisory group for
aerospace research and development, London 1970</p></li>
<li><p>Andrews, A. 1968, A square root formulation of the Kalman covariance equations, AIAA
Journal, 6:6, 1165-1166</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearGaussian</span></code></a>, optional) – A linear Gaussian measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
<li><p><strong>qr_method</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A switch to do the update via a QR decomposition, rather than using the (vector form of) the Potter method.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.SqrtKalmanUpdater.qr_method">
<span class="sig-name descname"><span class="pre">qr_method</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.SqrtKalmanUpdater.qr_method" title="Permalink to this definition"></a></dt>
<dd><p>A switch to do the update via a QR decomposition, rather than using the (vector form of) the Potter method.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.IteratedKalmanUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.kalman.</span></span><span class="sig-name descname"><span class="pre">IteratedKalmanUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.measures.html#smartfusion.measures.Measure" title="smartfusion.measures.Measure"><span class="pre">Measure</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">Euclidean(mapping=None,</span> <span class="pre">mapping2=None)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#IteratedKalmanUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.IteratedKalmanUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.kalman.ExtendedKalmanUpdater" title="smartfusion.updater.kalman.ExtendedKalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtendedKalmanUpdater</span></code></a></p>
<p>This version of the Kalman updater runs an iteration over the linearisation of the
sensor function in order to refine the posterior state estimate. Specifically,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x_{k,i+1} &amp;= x_{k|k-1} + K_i [z - h(x_{k,i}) - H_i (x_{k|k-1} - x_{k,i}) ]\\P_{k,i+1} &amp;= (I - K_i H_i) P_{k|k-1}\end{aligned}\end{align} \]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}H_i &amp;= h^{\prime}(x_{k,i}),\\K_i &amp;= P_{k|k-1} H_i^T (H_i P_{k|k-1} H_i^T + R)^{-1}\end{aligned}\end{align} \]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x_{k,0} &amp;= x_{k|k-1}\\P_{k,0} &amp;= P_{k|k-1}\end{aligned}\end{align} \]</div>
<p>It inherits from the ExtendedKalmanUpdater as it uses the same linearisation of the sensor
function via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">_measurement_matrix()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – A measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown. Must be linear or capable or implement the <code class="xref py py-meth docutils literal notranslate"><span class="pre">jacobian()</span></code>.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
<li><p><strong>tolerance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – The value of the difference in the measure used as a stopping criterion.</p></li>
<li><p><strong>measure</strong> (<a class="reference internal" href="smartfusion.measures.html#smartfusion.measures.Measure" title="smartfusion.measures.Measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Measure</span></code></a>, optional) – The measure to use to test the iteration stopping criterion. Defaults to the Euclidean distance between current and prior posterior state estimate.</p></li>
<li><p><strong>max_iterations</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – Number of iterations before while loop is exited and a non-convergence warning is returned</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.IteratedKalmanUpdater.tolerance">
<span class="sig-name descname"><span class="pre">tolerance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.IteratedKalmanUpdater.tolerance" title="Permalink to this definition"></a></dt>
<dd><p>The value of the difference in the measure used as a stopping criterion.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.IteratedKalmanUpdater.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.measures.html#smartfusion.measures.Measure" title="smartfusion.measures.Measure"><span class="pre">Measure</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.IteratedKalmanUpdater.measure" title="Permalink to this definition"></a></dt>
<dd><p>The measure to use to test the iteration stopping criterion. Defaults to the Euclidean distance between current and prior posterior state estimate.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.IteratedKalmanUpdater.max_iterations">
<span class="sig-name descname"><span class="pre">max_iterations</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><span class="pre">int</span></a></em><a class="headerlink" href="#smartfusion.updater.kalman.IteratedKalmanUpdater.max_iterations" title="Permalink to this definition"></a></dt>
<dd><p>Number of iterations before while loop is exited and a non-convergence warning is returned</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.kalman.IteratedKalmanUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/kalman.html#IteratedKalmanUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.kalman.IteratedKalmanUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>The iterated Kalman update method. Given a hypothesised association between a predicted
state or predicted measurement and an actual measurement,
calculate the posterior state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.SingleHypothesis" title="smartfusion.types.hypothesis.SingleHypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleHypothesis</span></code></a>) – the prediction-measurement association hypothesis. This hypothesis
may carry a predicted measurement, or a predicted state. In the
latter case a predicted measurement will be calculated.</p></li>
<li><p><strong>**kwargs</strong> (<em>various</em>) – These are passed to the measurement model function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The posterior state Gaussian with mean <span class="math notranslate nohighlight">\(\mathbf{x}_{k|k}\)</span> and
covariance <span class="math notranslate nohighlight">\(P_{k|k}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.GaussianStateUpdate" title="smartfusion.types.update.GaussianStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianStateUpdate</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-smartfusion.updater.particle">
<span id="particle"></span><h2>Particle<a class="headerlink" href="#module-smartfusion.updater.particle" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.particle.ParticleUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.particle.</span></span><span class="sig-name descname"><span class="pre">ParticleUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">resampler</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.resampler.html#smartfusion.resampler.base.Resampler" title="smartfusion.resampler.base.Resampler"><span class="pre">Resampler</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/particle.html#ParticleUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.particle.ParticleUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><code class="xref py py-class docutils literal notranslate"><span class="pre">Updater</span></code></a></p>
<p>Particle Updater</p>
<p>Perform an update by multiplying particle weights by PDF of measurement
model (either <a class="reference internal" href="smartfusion.types.html#smartfusion.types.detection.Detection.measurement_model" title="smartfusion.types.detection.Detection.measurement_model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_model</span></code></a> or
<code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_model</span></code>), and normalising the weights. If provided, a
<a class="reference internal" href="#smartfusion.updater.particle.ParticleUpdater.resampler" title="smartfusion.updater.particle.ParticleUpdater.resampler"><code class="xref py py-attr docutils literal notranslate"><span class="pre">resampler</span></code></a> will be used to take a new sample of particles (this is
called every time, and it’s up to the resampler to decide if resampling is
required).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – measurement model</p></li>
<li><p><strong>resampler</strong> (<a class="reference internal" href="smartfusion.resampler.html#smartfusion.resampler.base.Resampler" title="smartfusion.resampler.base.Resampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Resampler</span></code></a>, optional) – Resampler to prevent particle degeneracy</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.particle.ParticleUpdater.resampler">
<span class="sig-name descname"><span class="pre">resampler</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.resampler.html#smartfusion.resampler.base.Resampler" title="smartfusion.resampler.base.Resampler"><span class="pre">Resampler</span></a></em><a class="headerlink" href="#smartfusion.updater.particle.ParticleUpdater.resampler" title="Permalink to this definition"></a></dt>
<dd><p>Resampler to prevent particle degeneracy</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.particle.ParticleUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/particle.html#ParticleUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.particle.ParticleUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>Particle Filter update step</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.Hypothesis" title="smartfusion.types.hypothesis.Hypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hypothesis</span></code></a>) – Hypothesis with predicted state and associated detection used for
updating.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The state posterior</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.ParticleState" title="smartfusion.types.state.ParticleState"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleState</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.particle.ParticleUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_prediction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/particle.html#ParticleUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.particle.ParticleUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Get measurement prediction from state prediction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_prediction</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.StatePrediction" title="smartfusion.types.prediction.StatePrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">StatePrediction</span></code></a>) – The state prediction</p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – The measurement model used to generate the measurement prediction.
Should be used in cases where the measurement model is dependent
on the received measurement. The default is <cite>None</cite>, in which case
the updater will use the measurement model specified on
initialisation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The predicted measurement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.MeasurementPrediction" title="smartfusion.types.prediction.MeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementPrediction</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.particle.GromovFlowParticleUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.particle.</span></span><span class="sig-name descname"><span class="pre">GromovFlowParticleUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/particle.html#GromovFlowParticleUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.particle.GromovFlowParticleUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><code class="xref py py-class docutils literal notranslate"><span class="pre">Updater</span></code></a></p>
<p>Gromov Flow Particle Updater</p>
<p>This is implementation of Gromov method for stochastic particle flow
filters <a class="footnote-reference brackets" href="#id2" id="id1">1</a>. The Euler Maruyama method is used for integration, over 20
steps using an exponentially increase step size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – measurement model</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Daum, Fred &amp; Huang, Jim &amp; Noushin, Arjang. “Generalized Gromov
method for stochastic particle flow filters.” 2017</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.particle.GromovFlowParticleUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/particle.html#GromovFlowParticleUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.particle.GromovFlowParticleUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>Update state using prediction and measurement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.Hypothesis" title="smartfusion.types.hypothesis.Hypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hypothesis</span></code></a>) – Hypothesis with predicted state and associated detection used for
updating.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The state posterior</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.State" title="smartfusion.types.state.State"><code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.particle.GromovFlowParticleUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_prediction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#smartfusion.updater.particle.GromovFlowParticleUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Get measurement prediction from state prediction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_prediction</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.StatePrediction" title="smartfusion.types.prediction.StatePrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">StatePrediction</span></code></a>) – The state prediction</p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – The measurement model used to generate the measurement prediction.
Should be used in cases where the measurement model is dependent
on the received measurement. The default is <cite>None</cite>, in which case
the updater will use the measurement model specified on
initialisation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The predicted measurement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.MeasurementPrediction" title="smartfusion.types.prediction.MeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementPrediction</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.particle.GromovFlowKalmanParticleUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.particle.</span></span><span class="sig-name descname"><span class="pre">GromovFlowKalmanParticleUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">kalman_updater</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><span class="pre">KalmanUpdater</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/particle.html#GromovFlowKalmanParticleUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.particle.GromovFlowKalmanParticleUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.particle.GromovFlowParticleUpdater" title="smartfusion.updater.particle.GromovFlowParticleUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">GromovFlowParticleUpdater</span></code></a></p>
<p>Gromov Flow Parallel Kalman Particle Updater</p>
<p>This is a wrapper around the <a class="reference internal" href="#smartfusion.updater.particle.GromovFlowParticleUpdater" title="smartfusion.updater.particle.GromovFlowParticleUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">GromovFlowParticleUpdater</span></code></a> which
can use a <a class="reference internal" href="#smartfusion.updater.kalman.ExtendedKalmanUpdater" title="smartfusion.updater.kalman.ExtendedKalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtendedKalmanUpdater</span></code></a> or
<a class="reference internal" href="#smartfusion.updater.kalman.UnscentedKalmanUpdater" title="smartfusion.updater.kalman.UnscentedKalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnscentedKalmanUpdater</span></code></a> in parallel in order to maintain a state
covariance, as proposed in <a class="footnote-reference brackets" href="#id4" id="id3">2</a>. In this implementation, the mean of the
<a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.ParticleState" title="smartfusion.types.state.ParticleState"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleState</span></code></a> is used the EKF/UKF update.</p>
<p>This should be used in conjunction with the
<a class="reference internal" href="smartfusion.predictor.html#smartfusion.predictor.particle.ParticleFlowKalmanPredictor" title="smartfusion.predictor.particle.ParticleFlowKalmanPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleFlowKalmanPredictor</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – measurement model</p></li>
<li><p><strong>kalman_updater</strong> (<a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a>, optional) – Kalman updater to use. Default <cite>None</cite> where a new instance of:class:<cite>~.ExtendedKalmanUpdater</cite> will be created utilising thesame measurement model.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>Ding, Tao &amp; Coates, Mark J., “Implementation of the Daum-Huang
Exact-Flow Particle Filter” 2012</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.particle.GromovFlowKalmanParticleUpdater.kalman_updater">
<span class="sig-name descname"><span class="pre">kalman_updater</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><span class="pre">KalmanUpdater</span></a></em><a class="headerlink" href="#smartfusion.updater.particle.GromovFlowKalmanParticleUpdater.kalman_updater" title="Permalink to this definition"></a></dt>
<dd><p>Kalman updater to use. Default <cite>None</cite> where a new instance of:class:<cite>~.ExtendedKalmanUpdater</cite> will be created utilising thesame measurement model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.particle.GromovFlowKalmanParticleUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/particle.html#GromovFlowKalmanParticleUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.particle.GromovFlowKalmanParticleUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>Update state using prediction and measurement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.Hypothesis" title="smartfusion.types.hypothesis.Hypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hypothesis</span></code></a>) – Hypothesis with predicted state and associated detection used for
updating.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The state posterior</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.State" title="smartfusion.types.state.State"><code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.particle.GromovFlowKalmanParticleUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_prediction</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/particle.html#GromovFlowKalmanParticleUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.particle.GromovFlowKalmanParticleUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Get measurement prediction from state prediction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_prediction</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.StatePrediction" title="smartfusion.types.prediction.StatePrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">StatePrediction</span></code></a>) – The state prediction</p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – The measurement model used to generate the measurement prediction.
Should be used in cases where the measurement model is dependent
on the received measurement. The default is <cite>None</cite>, in which case
the updater will use the measurement model specified on
initialisation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The predicted measurement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.MeasurementPrediction" title="smartfusion.types.prediction.MeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementPrediction</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-smartfusion.updater.ensemble">
<span id="ensemble"></span><h2>Ensemble<a class="headerlink" href="#module-smartfusion.updater.ensemble" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.ensemble.EnsembleUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.ensemble.</span></span><span class="sig-name descname"><span class="pre">EnsembleUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/ensemble.html#EnsembleUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.ensemble.EnsembleUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a></p>
<p>Ensemble Kalman Filter Updater class
The EnKF is a hybrid of the Kalman updating scheme and the
Monte Carlo aproach of the the particle filter.</p>
<p>Deliberately structured to resemble the Vanilla Kalman Filter,
<a class="reference internal" href="#smartfusion.updater.ensemble.EnsembleUpdater.update" title="smartfusion.updater.ensemble.EnsembleUpdater.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> first calls <a class="reference internal" href="#smartfusion.updater.ensemble.EnsembleUpdater.predict_measurement" title="smartfusion.updater.ensemble.EnsembleUpdater.predict_measurement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_measurement()</span></code></a> function which
proceeds by calculating the predicted measurement, innovation covariance
and measurement cross-covariance. Note however, these are not propagated
explicitly, they are derived from the sample covariance of the ensemble
itself.</p>
<p>Note that the EnKF equations are simpler when written in the following
formalism. Note that h is not neccisarily a matrix, but could be a
nonlinear measurement function.</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_k = \hat{X} - E(X)
\mathbf{HA}_k = h(\hat{X} - E(X))\]</div>
<p>The cross covariance and measurement covariance are given by:</p>
<div class="math notranslate nohighlight">
\[P_{xz} = \frac{1}{M-1} \mathbf{A}_k \mathbf{HA}_k^T
P_{zz} = \frac{1}{M-1} A_k \mathbf{HA}_k^T + R\]</div>
<p>The Kalman gain is then calculated via:</p>
<div class="math notranslate nohighlight">
\[K_{k} = P_{xz} P_{zz}^{-1}\]</div>
<p>and the posterior state mean and covariance are,</p>
<div class="math notranslate nohighlight">
\[\mathbf{x}_{k|k} = \mathbf{x}_{k|k-1} + K_k (\mathbf{z}_k - H_k
\mathbf{x}_{k|k-1})\]</div>
<p>This is returned as a <a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.EnsembleStateUpdate" title="smartfusion.types.update.EnsembleStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnsembleStateUpdate</span></code></a> object.</p>
<p class="rubric">References</p>
<p>1. J. Hiles, S. M. O’Rourke, R. Niu and E. P. Blasch,
“Implementation of Ensemble Kalman Filters in Smart-Fusion,”
International Conference on Information Fusion, (2021)</p>
<p>2. Mandel, Jan. “A brief tutorial on the ensemble Kalman filter.”
arXiv preprint arXiv:0901.3725 (2009).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – A measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.ensemble.EnsembleUpdater.measurement_model">
<span class="sig-name descname"><span class="pre">measurement_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></em><a class="headerlink" href="#smartfusion.updater.ensemble.EnsembleUpdater.measurement_model" title="Permalink to this definition"></a></dt>
<dd><p>A measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.ensemble.EnsembleUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicted_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/ensemble.html#EnsembleUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.ensemble.EnsembleUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Predict the measurement implied by the predicted state mean</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pred_state</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.State" title="smartfusion.types.state.State"><code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code></a>) – The predicted state <span class="math notranslate nohighlight">\(\mathbf{x}_{k|k-1}\)</span></p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – The measurement model. If omitted, the model in the updater object
is used</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.EnsembleMeasurementPrediction" title="smartfusion.types.prediction.EnsembleMeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnsembleMeasurementPrediction</span></code></a></p></li>
<li><p>The measurement prediction, <span class="math notranslate nohighlight">\(\mathbf{z}_{k|k-1}\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.ensemble.EnsembleUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/ensemble.html#EnsembleUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.ensemble.EnsembleUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>The Ensemble Kalman update method. The Ensemble Kalman filter
simply uses the Kalman Update scheme
to evolve a set or Ensemble
of state vectors as a group. This ensemble of vectors contains all the
information on the system state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.SingleHypothesis" title="smartfusion.types.hypothesis.SingleHypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleHypothesis</span></code></a>) – the prediction-measurement association hypothesis. This hypothesis
may carry a predicted measurement, or a predicted state. In the
latter case a predicted measurement will be calculated.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The posterior state which contains an ensemble of state vectors
and a timestamp.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.EnsembleStateUpdate" title="smartfusion.types.update.EnsembleStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnsembleStateUpdate</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.ensemble.EnsembleSqrtUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.ensemble.</span></span><span class="sig-name descname"><span class="pre">EnsembleSqrtUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/ensemble.html#EnsembleSqrtUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.ensemble.EnsembleSqrtUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.ensemble.EnsembleUpdater" title="smartfusion.updater.ensemble.EnsembleUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnsembleUpdater</span></code></a></p>
<p>The Ensemble Square Root filter propagates the mean and square root
covariance through time, and samples a new ensemble.
This has the advantage of not requiring perturbation of the measurement
which reduces sampling error.
The posterior mean is calculated via:</p>
<div class="math notranslate nohighlight">
\[\mathbf{x}_{k|k} = \mathbf{x}_{k|k-1} + K_k (\mathbf{z}_k - H_k
\mathbf{x}_{k|k-1})\]</div>
<p>The Kalman gain is calculated via:</p>
<div class="math notranslate nohighlight">
\[K_{k} = P_{xz} P_{zz}^{-1}\]</div>
<p>The cross covariance and measurement covariance respectivley are approximated
via the sample square root covariances:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}P_{xz} \approx \tilde{P}_k (\tilde{Z}_k)^T\\P_{zz} \approx \tilde{Z}_k (\tilde{Z}_k)^T + R_k\end{aligned}\end{align} \]</div>
<p>and the posterior covariance is propaged through time via:</p>
<div class="math notranslate nohighlight">
\[\mathbf{P}_{k|k} = \tilde{P}^- B (\tilde{P}^- B)^T\]</div>
<p>Where <span class="math notranslate nohighlight">\(\tilde{P}^-\)</span> represents the prediction square root covariance
and B is the matrix square root of:</p>
<div class="math notranslate nohighlight">
\[B = \mathbf{I} - (\tilde{Z}_k)^T [P_{zz}]^{-1} \tilde{Z}_k\]</div>
<p>The posterior mean and covariance are used to sample a new ensemble.
The resulting state is returned via a <a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.EnsembleStateUpdate" title="smartfusion.types.update.EnsembleStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnsembleStateUpdate</span></code></a> object.</p>
<p class="rubric">References</p>
<p>1. J. Hiles, S. M. O’Rourke, R. Niu and E. P. Blasch,
“Implementation of Ensemble Kalman Filters in Smart-Fusion”,
International Conference on Information Fusion, (2021)</p>
<p>2. Livings, Dance, S. L., &amp; Nichols, N. K.
“Unbiased ensemble square root filters.”
Physica. D, 237(8), 1021–1028.  (2008)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>, optional) – A measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.ensemble.EnsembleSqrtUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/ensemble.html#EnsembleSqrtUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.ensemble.EnsembleSqrtUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>The Ensemble Square Root Kalman update method. The Ensemble Square
Root filter propagates the mean and square root covariance through time,
and samples a new ensemble. This has the advantage of not peturbing the
measurement with statistical noise, and thus is less prone to sampling
error for small ensembles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.SingleHypothesis" title="smartfusion.types.hypothesis.SingleHypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleHypothesis</span></code></a>) – the prediction-measurement association hypothesis. This hypothesis
may carry a predicted measurement, or a predicted state. In the
latter case a predicted measurement will be calculated.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The posterior state which contains an ensemble of state vectors
and a timestamp.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.EnsembleStateUpdate" title="smartfusion.types.update.EnsembleStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnsembleStateUpdate</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-smartfusion.updater.information">
<span id="information"></span><h2>Information<a class="headerlink" href="#module-smartfusion.updater.information" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.information.InformationKalmanUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.information.</span></span><span class="sig-name descname"><span class="pre">InformationKalmanUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><span class="pre">LinearGaussian</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/information.html#InformationKalmanUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.information.InformationKalmanUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a></p>
<p>A class which implements the update of information form of the Kalman filter. This is
conceptually very simple. The update proceeds as:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}Y_{k|k} = Y_{k|k-1} + H^{T}_k R^{-1}_k H_k\\\mathbf{y}_{k|k} = \mathbf{y}_{k|k-1} + H^{T}_k R^{-1}_k \mathbf{z}_{k}\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}_{k|k-1}\)</span> is the predicted information state and <span class="math notranslate nohighlight">\(Y_{k|k-1}\)</span> the
predicted information matrix which form the <a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.InformationStatePrediction" title="smartfusion.types.prediction.InformationStatePrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">InformationStatePrediction</span></code></a> object. The
measurement matrix <span class="math notranslate nohighlight">\(H_k\)</span> and measurement covariance <span class="math notranslate nohighlight">\(R_k\)</span> are those in the Kalman
filter (see tutorial 1). An <a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.InformationStateUpdate" title="smartfusion.types.update.InformationStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">InformationStateUpdate</span></code></a> object is returned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Analogously with the <a class="reference internal" href="smartfusion.predictor.html#smartfusion.predictor.information.InformationKalmanPredictor" title="smartfusion.predictor.information.InformationKalmanPredictor"><code class="xref py py-class docutils literal notranslate"><span class="pre">InformationKalmanPredictor</span></code></a>, the measurement model is queried
for the existence of an <code class="xref py py-meth docutils literal notranslate"><span class="pre">inverse_covar()</span></code> property. If absent, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">covar()</span></code> is
inverted.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearGaussian</span></code></a>, optional) – A linear Gaussian measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.information.InformationKalmanUpdater.measurement_model">
<span class="sig-name descname"><span class="pre">measurement_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><span class="pre">LinearGaussian</span></a></em><a class="headerlink" href="#smartfusion.updater.information.InformationKalmanUpdater.measurement_model" title="Permalink to this definition"></a></dt>
<dd><p>A linear Gaussian measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.information.InformationKalmanUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicted_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/information.html#InformationKalmanUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.information.InformationKalmanUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>There’s no direct analogue of a predicted measurement in the information form. This
method is therefore provided to return the predicted measurement as would the standard
Kalman updater. This is mainly for compatibility as it’s not anticipated that it would
be used in the usual operation of the information filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predicted_information_state</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.State" title="smartfusion.types.state.State"><code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code></a>) – The predicted state in information form <span class="math notranslate nohighlight">\(\mathbf{y}_{k|k-1}\)</span></p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – The measurement model. If omitted, the model in the updater object
is used</p></li>
<li><p><strong>**kwargs</strong> (<em>various</em>) – These are passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">matrix()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The measurement prediction, <span class="math notranslate nohighlight">\(H \mathbf{x}_{k|k-1}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.GaussianMeasurementPrediction" title="smartfusion.types.prediction.GaussianMeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianMeasurementPrediction</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.information.InformationKalmanUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/information.html#InformationKalmanUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.information.InformationKalmanUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>The Information filter update (corrector) method. Given a hypothesised association
between a predicted information state and an actual measurement, calculate the posterior
information state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.SingleHypothesis" title="smartfusion.types.hypothesis.SingleHypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleHypothesis</span></code></a>) – the prediction-measurement association hypothesis. This hypothesis
carries a predicted information state.</p></li>
<li><p><strong>**kwargs</strong> (<em>various</em>) – These are passed to <a class="reference internal" href="#smartfusion.updater.information.InformationKalmanUpdater.predict_measurement" title="smartfusion.updater.information.InformationKalmanUpdater.predict_measurement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_measurement()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The posterior information state with information state <span class="math notranslate nohighlight">\(\mathbf{y}_{k|k}\)</span> and
precision <span class="math notranslate nohighlight">\(Y_{k|k}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.InformationStateUpdate" title="smartfusion.types.update.InformationStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">InformationStateUpdate</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-smartfusion.updater.pointprocess">
<span id="point-process"></span><h2>Point Process<a class="headerlink" href="#module-smartfusion.updater.pointprocess" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.PointProcessUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.pointprocess.</span></span><span class="sig-name descname"><span class="pre">PointProcessUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updater</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><span class="pre">KalmanUpdater</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">clutter_spatial_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-26</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalisation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_detection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><span class="pre">Probability</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_survival</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><span class="pre">Probability</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/pointprocess.html#PointProcessUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.pointprocess.PointProcessUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="smartfusion.base.html#smartfusion.base.Base" title="smartfusion.base.Base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Base</span></code></a></p>
<p>Base updater class for the implementation of any Gaussian Mixture (GM)
point process derived multi target filters such as the
Probability Hypothesis Density (PHD),
Cardinalised Probability Hypothesis Density (CPHD) or
Linear Complexity with Cumulants (LCC) filters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>updater</strong> (<a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a>) – Underlying updater used to perform the              single target Kalman Update.</p></li>
<li><p><strong>clutter_spatial_density</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Spatial density of the clutter process uniformly             distributed across the state space.</p></li>
<li><p><strong>normalisation</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – Flag for normalisation</p></li>
<li><p><strong>prob_detection</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><code class="xref py py-class docutils literal notranslate"><span class="pre">Probability</span></code></a>, optional) – Probability of a target being detected at the current timestep</p></li>
<li><p><strong>prob_survival</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><code class="xref py py-class docutils literal notranslate"><span class="pre">Probability</span></code></a>, optional) – Probability of a target surviving until the next timestep</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.PointProcessUpdater.updater">
<span class="sig-name descname"><span class="pre">updater</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><span class="pre">KalmanUpdater</span></a></em><a class="headerlink" href="#smartfusion.updater.pointprocess.PointProcessUpdater.updater" title="Permalink to this definition"></a></dt>
<dd><p>Underlying updater used to perform the              single target Kalman Update.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.PointProcessUpdater.clutter_spatial_density">
<span class="sig-name descname"><span class="pre">clutter_spatial_density</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.pointprocess.PointProcessUpdater.clutter_spatial_density" title="Permalink to this definition"></a></dt>
<dd><p>Spatial density of the clutter process uniformly             distributed across the state space.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.PointProcessUpdater.normalisation">
<span class="sig-name descname"><span class="pre">normalisation</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></em><a class="headerlink" href="#smartfusion.updater.pointprocess.PointProcessUpdater.normalisation" title="Permalink to this definition"></a></dt>
<dd><p>Flag for normalisation</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.PointProcessUpdater.prob_detection">
<span class="sig-name descname"><span class="pre">prob_detection</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><span class="pre">Probability</span></a></em><a class="headerlink" href="#smartfusion.updater.pointprocess.PointProcessUpdater.prob_detection" title="Permalink to this definition"></a></dt>
<dd><p>Probability of a target being detected at the current timestep</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.PointProcessUpdater.prob_survival">
<span class="sig-name descname"><span class="pre">prob_survival</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><span class="pre">Probability</span></a></em><a class="headerlink" href="#smartfusion.updater.pointprocess.PointProcessUpdater.prob_survival" title="Permalink to this definition"></a></dt>
<dd><p>Probability of a target surviving until the next timestep</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.PointProcessUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypotheses</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/pointprocess.html#PointProcessUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.pointprocess.PointProcessUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>Updates the current components in a
<code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianMixture</span></code> by applying the underlying         <code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code> updater to each component         with the supplied measurements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hypotheses</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">MultipleHypothesis</span></code>) – Measurements obtained at time <span class="math notranslate nohighlight">\(k+1\)</span></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>updated_components</strong> – GaussianMixtureMultiTargetTracker with updated             components at time <span class="math notranslate nohighlight">\(k+1\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianMixtureUpdate</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.PHDUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.pointprocess.</span></span><span class="sig-name descname"><span class="pre">PHDUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updater</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><span class="pre">KalmanUpdater</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">clutter_spatial_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-26</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalisation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_detection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><span class="pre">Probability</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_survival</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><span class="pre">Probability</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/pointprocess.html#PHDUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.pointprocess.PHDUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.pointprocess.PointProcessUpdater" title="smartfusion.updater.pointprocess.PointProcessUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointProcessUpdater</span></code></a></p>
<p>A implementation of the Gaussian Mixture
Probability Hypothesis Density (GM-PHD) multi-target filter</p>
<p class="rubric">References</p>
<p>[1] B.-N. Vo and W.-K. Ma, “The Gaussian Mixture Probability Hypothesis
Density Filter,” Signal Processing,IEEE Transactions on, vol. 54, no. 11,
pp. 4091–4104, 2006. <a class="reference external" href="https://ieeexplore.ieee.org/document/1710358">https://ieeexplore.ieee.org/document/1710358</a>.</p>
<p>[2] D. E. Clark, K. Panta and B. Vo, “The GM-PHD Filter Multiple Target Tracker,” 2006 9th
International Conference on Information Fusion, 2006, pp. 1-8, doi: 10.1109/ICIF.2006.301809.
<a class="reference external" href="https://ieeexplore.ieee.org/document/4086095">https://ieeexplore.ieee.org/document/4086095</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>updater</strong> (<a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a>) – Underlying updater used to perform the              single target Kalman Update.</p></li>
<li><p><strong>clutter_spatial_density</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Spatial density of the clutter process uniformly             distributed across the state space.</p></li>
<li><p><strong>normalisation</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – Flag for normalisation</p></li>
<li><p><strong>prob_detection</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><code class="xref py py-class docutils literal notranslate"><span class="pre">Probability</span></code></a>, optional) – Probability of a target being detected at the current timestep</p></li>
<li><p><strong>prob_survival</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><code class="xref py py-class docutils literal notranslate"><span class="pre">Probability</span></code></a>, optional) – Probability of a target surviving until the next timestep</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.LCCUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.pointprocess.</span></span><span class="sig-name descname"><span class="pre">LCCUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updater</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><span class="pre">KalmanUpdater</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">clutter_spatial_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-26</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalisation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_detection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><span class="pre">Probability</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_survival</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><span class="pre">Probability</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean_number_of_false_alarms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance_of_false_alarms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/pointprocess.html#LCCUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.pointprocess.LCCUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.pointprocess.PointProcessUpdater" title="smartfusion.updater.pointprocess.PointProcessUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointProcessUpdater</span></code></a></p>
<p>A implementation of the Gaussian Mixture
Linear Complexity with Cumulants (GM-LCC) multi-target filter</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] D. E. Clark and F. De Melo. “A Linear-Complexity Second-Order</dt><dd><p>Multi-Object Filter via Factorial Cumulants”.
In: 2018 21st International Conference on
Information Fusion (FUSION). 2018. DOI: 10.
23919/ICIF.2018.8455331. <a class="reference external" href="https://ieeexplore.ieee.org/document/8455331">https://ieeexplore.ieee.org/document/8455331</a>..</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>updater</strong> (<a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a>) – Underlying updater used to perform the              single target Kalman Update.</p></li>
<li><p><strong>clutter_spatial_density</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Spatial density of the clutter process uniformly             distributed across the state space.</p></li>
<li><p><strong>normalisation</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – Flag for normalisation</p></li>
<li><p><strong>prob_detection</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><code class="xref py py-class docutils literal notranslate"><span class="pre">Probability</span></code></a>, optional) – Probability of a target being detected at the current timestep</p></li>
<li><p><strong>prob_survival</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.numeric.Probability" title="smartfusion.types.numeric.Probability"><code class="xref py py-class docutils literal notranslate"><span class="pre">Probability</span></code></a>, optional) – Probability of a target surviving until the next timestep</p></li>
<li><p><strong>mean_number_of_false_alarms</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Mean number of false alarms (clutter) expected per timestep</p></li>
<li><p><strong>variance_of_false_alarms</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Variance on the number of false alarms (clutter) expected per timestep</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.LCCUpdater.mean_number_of_false_alarms">
<span class="sig-name descname"><span class="pre">mean_number_of_false_alarms</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.pointprocess.LCCUpdater.mean_number_of_false_alarms" title="Permalink to this definition"></a></dt>
<dd><p>Mean number of false alarms (clutter) expected per timestep</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.pointprocess.LCCUpdater.variance_of_false_alarms">
<span class="sig-name descname"><span class="pre">variance_of_false_alarms</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.pointprocess.LCCUpdater.variance_of_false_alarms" title="Permalink to this definition"></a></dt>
<dd><p>Variance on the number of false alarms (clutter) expected per timestep</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-smartfusion.updater.alphabeta">
<span id="alphabeta"></span><h2>AlphaBeta<a class="headerlink" href="#module-smartfusion.updater.alphabeta" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.alphabeta.AlphaBetaUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.alphabeta.</span></span><span class="sig-name descname"><span class="pre">AlphaBetaUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmap</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">ndarray</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/alphabeta.html#AlphaBetaUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.alphabeta.AlphaBetaUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><code class="xref py py-class docutils literal notranslate"><span class="pre">Updater</span></code></a></p>
<p>Conceptually, the <span class="math notranslate nohighlight">\(\alpha-\beta\)</span> filter is similar to its Kalman cousins in that it
operates recursively over predict and update steps. It assumes that a state vector is
decomposable into quantities and the rates of change of those quantities. We refer to these as
position <span class="math notranslate nohighlight">\(p\)</span> and velocity <span class="math notranslate nohighlight">\(v\)</span> respectively, though they aren’t confined to
locations in space. If the interval from <span class="math notranslate nohighlight">\(t_{k-1} \rightarrow t_k\)</span> is <span class="math notranslate nohighlight">\(\Delta T\)</span>,
and at <span class="math notranslate nohighlight">\(k\)</span>, we can gain a (noisy) measurement of the position, <span class="math notranslate nohighlight">\(p^z_k\)</span>.</p>
<p>The recursion proceeds as:</p>
<ul class="simple">
<li><p>Predict</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}p_{k|k-1} &amp;= p_{k-1} + \Delta T v_{k-1}\\v_{k|k-1} &amp;= v_{k-1}\end{aligned}\end{align} \]</div>
<ul class="simple">
<li><p>Update</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}s_k &amp;= p^z_k - p_{k|k-1} \: (\mathrm{innovation})\\p_k &amp;= p_{k|k-1} + \alpha s_k\\v_k &amp;= v_{k|k-1} + \frac{\beta}{\Delta T} s_k\end{aligned}\end{align} \]</div>
<p>The <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> parameters which give the filter its name are small,
<span class="math notranslate nohighlight">\(0 &lt; \alpha &lt; 1\)</span> and <span class="math notranslate nohighlight">\(0 &lt; \beta \leq 2\)</span>. Colloquially, the larger the values of the
parameters, the more influence the measurements have over the transition model; <span class="math notranslate nohighlight">\(\beta\)</span>
is usually much smaller than <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>As the prediction is just the application of a constant velocity model, there is no
<span class="math notranslate nohighlight">\(\alpha-\beta\)</span> predictor provided in SMART FUSION. It is assumed that the predictions
passed to the hypothesis have been generated by a constant velocity model. Any application of a
control model is also assumed to have taken place during the prediction stage.</p>
<p>This class assumes the velocity is in units of the length per second. If different units are
required, scale the prior appropriately.</p>
<p>The measurement model used should be linear and a measurement model such that it provides a
‘mapping’ to <span class="math notranslate nohighlight">\(p\)</span> via the <code class="xref py py-attr docutils literal notranslate"><span class="pre">mapping</span></code> tuple and a binary measurement matrix which
returns <span class="math notranslate nohighlight">\(p\)</span>. This isn’t checked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – measurement model</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The alpha parameter. Controls the weight given to the measurements over the transition model.</p></li>
<li><p><strong>beta</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The beta parameter. Controls the amount of variation allowed in the velocity component.</p></li>
<li><p><strong>vmap</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>, optional) – Binary map of the velocity elements in the state vector. If left default, the class will assume that the velocity elements interleave the position elements in the state vector.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.alphabeta.AlphaBetaUpdater.alpha">
<span class="sig-name descname"><span class="pre">alpha</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.alphabeta.AlphaBetaUpdater.alpha" title="Permalink to this definition"></a></dt>
<dd><p>The alpha parameter. Controls the weight given to the measurements over the transition model.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.alphabeta.AlphaBetaUpdater.beta">
<span class="sig-name descname"><span class="pre">beta</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.alphabeta.AlphaBetaUpdater.beta" title="Permalink to this definition"></a></dt>
<dd><p>The beta parameter. Controls the amount of variation allowed in the velocity component.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.alphabeta.AlphaBetaUpdater.vmap">
<span class="sig-name descname"><span class="pre">vmap</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">ndarray</span></a></em><a class="headerlink" href="#smartfusion.updater.alphabeta.AlphaBetaUpdater.vmap" title="Permalink to this definition"></a></dt>
<dd><p>Binary map of the velocity elements in the state vector. If left default, the class will assume that the velocity elements interleave the position elements in the state vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.alphabeta.AlphaBetaUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prediction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/alphabeta.html#AlphaBetaUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.alphabeta.AlphaBetaUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Return the predicted measurement</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prediction</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.StatePrediction" title="smartfusion.types.prediction.StatePrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">StatePrediction</span></code></a>) – The state prediction</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The predicted measurement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.array.StateVector" title="smartfusion.types.array.StateVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">StateVector</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.alphabeta.AlphaBetaUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_interval</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/alphabeta.html#AlphaBetaUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.alphabeta.AlphaBetaUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the inferred state following update</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.Hypothesis" title="smartfusion.types.hypothesis.Hypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hypothesis</span></code></a>) – A hypothesis associates a measurement with a prediction</p></li>
<li><p><strong>time_interval</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code>) – The time interval over which the prediction has been made.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The updated state</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.StateUpdate" title="smartfusion.types.update.StateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">StateUpdate</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-smartfusion.updater.slidinginnovation">
<span id="sliding-innovation-filter"></span><h2>Sliding Innovation Filter<a class="headerlink" href="#module-smartfusion.updater.slidinginnovation" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.slidinginnovation.SlidingInnovationUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.slidinginnovation.</span></span><span class="sig-name descname"><span class="pre">SlidingInnovationUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_width</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">ndarray</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><span class="pre">LinearGaussian</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/slidinginnovation.html#SlidingInnovationUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.slidinginnovation.SlidingInnovationUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.kalman.KalmanUpdater" title="smartfusion.updater.kalman.KalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">KalmanUpdater</span></code></a></p>
<p>Sliding Innovation Filter Updater</p>
<p>The Sliding Innovation Filter (SIF) is a sub-optimal filter (in comparison to Kalman filter)
which uses a switching gain to provide robustness to estimation problems that may be
ill-conditioned or contain modeling uncertainties or disturbances.</p>
<p>The main difference from Kalman filter is the calculation of the gain:</p>
<div class="math notranslate nohighlight">
\[K_k = H_k^+ \overline{sat}(|\mathbf{z}_{k|k-1}|/\mathbf{\delta})\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{\delta}\)</span> is the sliding boundary layer width.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>S. A. Gadsden and M. Al-Shabi, “The Sliding Innovation Filter,” in IEEE Access, vol. 8,
pp. 96129-96138, 2020, doi: 10.1109/ACCESS.2020.2995345.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_width</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – Sliding boundary layer width <span class="math notranslate nohighlight">\(\mathbf{\delta}\)</span>. A tunable parameter in measurement space. An example initial value provided in original paper is <span class="math notranslate nohighlight">\(10 \times \text{diag}(R)\)</span></p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearGaussian</span></code></a>, optional) – A linear Gaussian measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.slidinginnovation.SlidingInnovationUpdater.layer_width">
<span class="sig-name descname"><span class="pre">layer_width</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">ndarray</span></a></em><a class="headerlink" href="#smartfusion.updater.slidinginnovation.SlidingInnovationUpdater.layer_width" title="Permalink to this definition"></a></dt>
<dd><p>Sliding boundary layer width <span class="math notranslate nohighlight">\(\mathbf{\delta}\)</span>. A tunable parameter in measurement space. An example initial value provided in original paper is <span class="math notranslate nohighlight">\(10 \times \text{diag}(R)\)</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.slidinginnovation.ExtendedSlidingInnovationUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.slidinginnovation.</span></span><span class="sig-name descname"><span class="pre">ExtendedSlidingInnovationUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_width</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">ndarray</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><span class="pre">LinearGaussian</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/slidinginnovation.html#ExtendedSlidingInnovationUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.slidinginnovation.ExtendedSlidingInnovationUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.slidinginnovation.SlidingInnovationUpdater" title="smartfusion.updater.slidinginnovation.SlidingInnovationUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">SlidingInnovationUpdater</span></code></a>, <a class="reference internal" href="#smartfusion.updater.kalman.ExtendedKalmanUpdater" title="smartfusion.updater.kalman.ExtendedKalmanUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtendedKalmanUpdater</span></code></a></p>
<p>Extended Sliding Innovation Filter Updater</p>
<p>This is the Extended version of the <a class="reference internal" href="#smartfusion.updater.slidinginnovation.SlidingInnovationUpdater" title="smartfusion.updater.slidinginnovation.SlidingInnovationUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">SlidingInnovationUpdater</span></code></a> for non-linear
measurement models.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>S. A. Gadsden and M. Al-Shabi, “The Sliding Innovation Filter,” in IEEE Access, vol. 8,
pp. 96129-96138, 2020, doi: 10.1109/ACCESS.2020.2995345.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_width</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – Sliding boundary layer width <span class="math notranslate nohighlight">\(\mathbf{\delta}\)</span>. A tunable parameter in measurement space. An example initial value provided in original paper is <span class="math notranslate nohighlight">\(10 \times \text{diag}(R)\)</span></p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.linear.LinearGaussian" title="smartfusion.models.measurement.linear.LinearGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearGaussian</span></code></a>, optional) – A linear Gaussian measurement model. This need not be defined if a measurement model is provided in the measurement. If no model specified on construction, or in the measurement, then error will be thrown.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag to force the output covariance matrix to be symmetric by way of a simple geometric combination of the matrix and transpose. Default is False.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-smartfusion.updater.categorical">
<span id="categorical"></span><h2>Categorical<a class="headerlink" href="#module-smartfusion.updater.categorical" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.categorical.HMMUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.categorical.</span></span><span class="sig-name descname"><span class="pre">HMMUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.categorical.MarkovianMeasurementModel" title="smartfusion.models.measurement.categorical.MarkovianMeasurementModel"><span class="pre">MarkovianMeasurementModel</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/categorical.html#HMMUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.categorical.HMMUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><code class="xref py py-class docutils literal notranslate"><span class="pre">Updater</span></code></a></p>
<p>Hidden Markov model updater</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.categorical.MarkovianMeasurementModel" title="smartfusion.models.measurement.categorical.MarkovianMeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MarkovianMeasurementModel</span></code></a>, optional) – The measurement model used to predict measurement vectors. If no model is specified on construction, or in a measurement, then an error will be thrown.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.categorical.HMMUpdater.measurement_model">
<span class="sig-name descname"><span class="pre">measurement_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.categorical.MarkovianMeasurementModel" title="smartfusion.models.measurement.categorical.MarkovianMeasurementModel"><span class="pre">MarkovianMeasurementModel</span></a></em><a class="headerlink" href="#smartfusion.updater.categorical.HMMUpdater.measurement_model" title="Permalink to this definition"></a></dt>
<dd><p>The measurement model used to predict measurement vectors. If no model is specified on construction, or in a measurement, then an error will be thrown.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.categorical.HMMUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/categorical.html#HMMUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.categorical.HMMUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>The update method. Given a hypothesised association between a predicted state or
predicted measurement and an actual measurement, calculate the posterior state.</p>
<div class="math notranslate nohighlight">
\[\alpha_t^i = E^{ki}(F\alpha_{t-1})^i\]</div>
<p>Measurements are assumed to be discrete categories from a finite set of measurement
categories <span class="math notranslate nohighlight">\(Z = \{\zeta^n|n\in \mathbf{N}, n\le N\}\)</span> (for some finite <span class="math notranslate nohighlight">\(N\)</span>).
A measurement should be equivalent to a basis vector <span class="math notranslate nohighlight">\(e^k\)</span>, (the N-tuple with all
components equal to 0, except the k-th (indices starting at 0), which is 1). This
indicates that the measured category is <span class="math notranslate nohighlight">\(\zeta^k\)</span>.</p>
<p>The equation above can be simplified to:</p>
<div class="math notranslate nohighlight">
\[\alpha_t = E^Ty_t \circ F\alpha_{t-1}\]</div>
<p>where <span class="math notranslate nohighlight">\(\circ\)</span> denotes element-wise (Hadamard) product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.SingleHypothesis" title="smartfusion.types.hypothesis.SingleHypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleHypothesis</span></code></a>) – the prediction-measurement association hypothesis. This hypothesis may carry a
predicted measurement, or a predicted state. In the latter case a predicted
measurement will be calculated.</p></li>
<li><p><strong>**kwargs</strong> (<em>various</em>) – These are passed to <a class="reference internal" href="#smartfusion.updater.categorical.HMMUpdater.predict_measurement" title="smartfusion.updater.categorical.HMMUpdater.predict_measurement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_measurement()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The posterior categorical state.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.CategoricalStateUpdate" title="smartfusion.types.update.CategoricalStateUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalStateUpdate</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.categorical.HMMUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicted_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/categorical.html#HMMUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.categorical.HMMUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>Predict the measurement implied by the predicted state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predicted_state</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.CategoricalState" title="smartfusion.types.state.CategoricalState"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalState</span></code></a>) – The predicted state.</p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – The measurement model. If omitted, the model in the updater object is used.</p></li>
<li><p><strong>measurement</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.CategoricalState" title="smartfusion.types.state.CategoricalState"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalState</span></code></a>.) – The measurement.</p></li>
<li><p><strong>**kwargs</strong> (<em>various</em>) – These are passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">function()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The measurement prediction.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.CategoricalMeasurementPrediction" title="smartfusion.types.prediction.CategoricalMeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalMeasurementPrediction</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-smartfusion.updater.composite">
<span id="composite"></span><h2>Composite<a class="headerlink" href="#module-smartfusion.updater.composite" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.composite.CompositeUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.composite.</span></span><span class="sig-name descname"><span class="pre">CompositeUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub_updaters</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><span class="pre">Updater</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/composite.html#CompositeUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.composite.CompositeUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><code class="xref py py-class docutils literal notranslate"><span class="pre">Updater</span></code></a></p>
<p>Composite updater type</p>
<p>A composition of sub-updaters (<a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><code class="xref py py-class docutils literal notranslate"><span class="pre">Updater</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sub_updaters</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence[Updater]</span></code>) – Sequence of sub-updaters comprising the composite updater. Must not be empty.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.composite.CompositeUpdater.sub_updaters">
<span class="sig-name descname"><span class="pre">sub_updaters</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.10)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><span class="pre">Updater</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#smartfusion.updater.composite.CompositeUpdater.sub_updaters" title="Permalink to this definition"></a></dt>
<dd><p>Sequence of sub-updaters comprising the composite updater. Must not be empty.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="smartfusion.updater.composite.CompositeUpdater.measurement_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">measurement_model</span></span><a class="headerlink" href="#smartfusion.updater.composite.CompositeUpdater.measurement_model" title="Permalink to this definition"></a></dt>
<dd><p>measurement model</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.composite.CompositeUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/composite.html#CompositeUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.composite.CompositeUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>To attain measurement predictions, the composite updater will use it’s sub-updaters’
<cite>predict_measurement</cite> methods and leave combining these to the
<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.CompositeHypothesis" title="smartfusion.types.hypothesis.CompositeHypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeHypothesis</span></code></a> type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.composite.CompositeUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.CompositeHypothesis" title="smartfusion.types.hypothesis.CompositeHypothesis"><span class="pre">CompositeHypothesis</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/composite.html#CompositeUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.composite.CompositeUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>Given a hypothesised association between a composite predicted state or composite
predicted measurement and a composite measurement, calculate the composite
posterior state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.CompositeHypothesis" title="smartfusion.types.hypothesis.CompositeHypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeHypothesis</span></code></a>) – the prediction-measurement association hypothesis. This hypothesis may carry a
composite predicted measurement, or a composite predicted state. In the latter case
a measurement prediction is calculated for each sub-state of the composite hypothesis,
which will then create its own composite measurement prediction.</p></li>
<li><p><strong>**kwargs</strong> (<em>various</em>) – These are passed to the <a class="reference internal" href="#smartfusion.updater.composite.CompositeUpdater.predict_measurement" title="smartfusion.updater.composite.CompositeUpdater.predict_measurement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_measurement()</span></code></a> method of each sub-updater</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The posterior composite state update</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.CompositeUpdate" title="smartfusion.types.update.CompositeUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeUpdate</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-smartfusion.updater.chernoff">
<span id="chernoff"></span><h2>Chernoff<a class="headerlink" href="#module-smartfusion.updater.chernoff" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="smartfusion.updater.chernoff.ChernoffUpdater">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">smartfusion.updater.chernoff.</span></span><span class="sig-name descname"><span class="pre">ChernoffUpdater</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><span class="pre">MeasurementModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/chernoff.html#ChernoffUpdater"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.chernoff.ChernoffUpdater" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#smartfusion.updater.base.Updater" title="smartfusion.updater.base.Updater"><code class="xref py py-class docutils literal notranslate"><span class="pre">Updater</span></code></a></p>
<p>A class which performs state updates using the Chernoff fusion rule. In this context,
measurements come in the form of states with a mean and covariance (compared to traditional
measurements which contain solely a mean). The measurements are expected to come as
<a class="reference internal" href="smartfusion.types.html#smartfusion.types.detection.GaussianDetection" title="smartfusion.types.detection.GaussianDetection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianDetection</span></code></a> objects.</p>
<p>The Chernoff fusion rule is written as <a class="footnote-reference brackets" href="#id9" id="id5">3</a></p>
<div class="math notranslate nohighlight">
\[p_{\omega}(x_{k}) = \frac{p_{1}(x_{k})^{\omega}p_{2}(x_{k})^{1-\omega}}
                         {\int p_{1}(x)^{\omega}p_{2}(x)^{1-\omega} \mathrm{d} x}\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega\)</span> is a weighting parameter in the range <span class="math notranslate nohighlight">\((0,1]\)</span>, which can be found
using an optimization algorithm.</p>
<p>In situations where <span class="math notranslate nohighlight">\(p_1(x)\)</span> and <span class="math notranslate nohighlight">\(p_2(x)\)</span> are multivariate Gaussian distributions,
the above formula is equal to the Covariance Intersection Algorithm from Julier et al <a class="footnote-reference brackets" href="#id10" id="id6">4</a>.
Let <span class="math notranslate nohighlight">\((a,A)\)</span> and <span class="math notranslate nohighlight">\((b,B)\)</span> be the means and covariances of the measurement and
prediction respectively. The Covariance Intersection Algorithm was reformulated for use in
Bayesian state estimation by Clark and Campbell <a class="footnote-reference brackets" href="#id11" id="id7">5</a>, yielding formulas for the updated
covariance and mean, <span class="math notranslate nohighlight">\(D\)</span> and <span class="math notranslate nohighlight">\(d\)</span>, and the innovation covariance matrix, <span class="math notranslate nohighlight">\(V\)</span>,
as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}D &amp;= \left ( \omega A^{-1} + (1-\omega)B^{-1} \right )\\
d &amp;= D \left ( \omega A^{-1}a + (1-\omega)B^{-1}b \right )\\
V &amp;= \frac{A}{1-\omega} + \frac{B}{\omega}\end{split}\]</div>
<p>In filters where gating is required, the gating region can be written using the innovation
covariance matrix as:</p>
<div class="math notranslate nohighlight">
\[\mathcal{V}(\gamma) = \left\{ (a,A) : (a-b)^T V^{-1} (a-b) \leq \gamma \right\}\]</div>
<p>The specifics for implementing the Covariance Intersection Algorithm in several popular
multi-target tracking algorithms was expanded upon by Clark et al <a class="footnote-reference brackets" href="#id12" id="id8">6</a>. The work includes a
discussion of SMART FUSION and can be used to apply this class to a tracking algorithm of
choice.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you have tracks that you would like to use as measurements for this updater, the
<a class="reference internal" href="smartfusion.feeder.html#smartfusion.feeder.track.Tracks2GaussianDetectionFeeder" title="smartfusion.feeder.track.Tracks2GaussianDetectionFeeder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracks2GaussianDetectionFeeder</span></code></a> class can be used to convert the tracks to the
appropriate format.</p>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>Hurley, M., “An information theoretic justification for covariance intersection and its
generalization,” in [Proceedings of the Fifth International Conference on Information
Fusion. FUSION 2002.(IEEE Cat. No. 02EX5997) ], 1, 505–511, IEEE (2002).
<a class="reference external" href="https://ieeexplore.ieee.org/document/1021196">https://ieeexplore.ieee.org/document/1021196</a>.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>Julier, S., Uhlmann, J., and Durrant-Whyte, H., “A new method for the nonlinear
transformation of means and covariances in filters and estimators,” IEEE Transactions on
automatic control 45(3), 477–482 (2000).
<a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/847726/similar#similar">https://ieeexplore.ieee.org/abstract/document/847726/similar#similar</a>.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id7">5</a></span></dt>
<dd><p>Clark, D. and Campbell, M., “Integrating covariance intersection into Bayesian
multi-target tracking filters,” preprint on TechRxiv. submitted to IEEE Transactions on
Aerospace and Electronic Systems.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id8">6</a></span></dt>
<dd><p>Clark, D. and Hunter, E. and Balaji, B. and O’Rourke, S., “Centralized multi-sensor
multi-target data fusion with tracks as measurements,” to be submitted to SPIE Defense and
Security Symposium 2023.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – measurement model</p></li>
<li><p><strong>omega</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – A weighting parameter in the range <span class="math notranslate nohighlight">\((0,1]\)</span></p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="smartfusion.updater.chernoff.ChernoffUpdater.omega">
<span class="sig-name descname"><span class="pre">omega</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><span class="pre">float</span></a></em><a class="headerlink" href="#smartfusion.updater.chernoff.ChernoffUpdater.omega" title="Permalink to this definition"></a></dt>
<dd><p>A weighting parameter in the range <span class="math notranslate nohighlight">\((0,1]\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.chernoff.ChernoffUpdater.predict_measurement">
<span class="sig-name descname"><span class="pre">predict_measurement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicted_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/chernoff.html#ChernoffUpdater.predict_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.chernoff.ChernoffUpdater.predict_measurement" title="Permalink to this definition"></a></dt>
<dd><p>This function predicts the measurement of a state in situations where measurements consist
of a covariance and state vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predicted_state</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.state.GaussianState" title="smartfusion.types.state.GaussianState"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianState</span></code></a>) – The predicted state <span class="math notranslate nohighlight">\(\mathbf{x}_{k|k-1}\)</span></p></li>
<li><p><strong>measurement_model</strong> (<a class="reference internal" href="smartfusion.models.measurement.html#smartfusion.models.measurement.base.MeasurementModel" title="smartfusion.models.measurement.base.MeasurementModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementModel</span></code></a>) – The measurement model. If omitted, the updater will use the model that was specified
on initialization.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The measurement prediction</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.prediction.MeasurementPrediction" title="smartfusion.types.prediction.MeasurementPrediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeasurementPrediction</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="smartfusion.updater.chernoff.ChernoffUpdater.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hypothesis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_symmetric_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/smartfusion/updater/chernoff.html#ChernoffUpdater.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#smartfusion.updater.chernoff.ChernoffUpdater.update" title="Permalink to this definition"></a></dt>
<dd><p>Given a hypothesis, calculate the posterior mean and covariance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hypothesis</strong> (<a class="reference internal" href="smartfusion.types.html#smartfusion.types.hypothesis.Hypothesis" title="smartfusion.types.hypothesis.Hypothesis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hypothesis</span></code></a>) – Hypothesis with the predicted state and the actual/associated measurement which should
be used for updating. If the hypothesis does not contain a measurement prediction, one
will be calculated.</p></li>
<li><p><strong>force_symmetric_covariance</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a>) – A flag to force the output covariance matrix to be symmetric by way of a simple
geometric combination of the matrix and transpose. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The state posterior, saved in a generic <a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.Update" title="smartfusion.types.update.Update"><code class="xref py py-class docutils literal notranslate"><span class="pre">Update</span></code></a> object.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="smartfusion.types.html#smartfusion.types.update.Update" title="smartfusion.types.update.Update"><code class="xref py py-class docutils literal notranslate"><span class="pre">Update</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="smartfusion.smoother.html" class="btn btn-neutral float-left" title="Smoothers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="smartfusion.types.html" class="btn btn-neutral float-right" title="Data Types" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="copyright.html">Copyright</a> 2022 University of Oklahoma.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>